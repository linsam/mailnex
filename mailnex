#!/usr/bin/env python2
# Ubuntu 14.04 doesn't have xapian for python3. Quite possibly other modules
# aren't available as well.
#
# I might have to demarcate Ubuntu 16.04 and CentOS 7 as minimum OSes. Don't
# know *yet* if packages are supported there either.
#
# At any rate, might as well make this module as close to python 3 as possible
# for now, so that once we can change over, it'll be easier.
from __future__ import print_function
from __future__ import unicode_literals

debug = 1
imapdebug = 0
debug_parse = 0

#  Search indexing
#  ---------------
# Terms:
#  * Document - unit of search result. Documents have a 32bit id, data, terms,
#  and values.
#       * Data - binary blob, opaque to the engine. You can put the whole body
#       of a document here, or abstracts, or references to the real thing. For
#       email, this would probably be a message-id and/or mailfolder+UID
#       * terms - queryable data. Links to docuements, sortof. Terms can also
#       be field associated (e.g. sender vs body vs date)
#           * xapian supports mapping a field to multiple field prefixes
#           * We could use that such that To and CC map to recipient, and To,
#           CC, From, etc. map to person, etc.
#           * Check the Xapian conventions ('A' for author, etc) for a default
#           set of prefixes before running with our own.
#       * values - advanced topic for advanced searches 
#           * can be sorting keys
#           * can be weight (document importance)
#           * can be numeric values for range sort (dates come to mind)
#           * Values are stored into a slot between 0x0 and 0xfffffffe
#           * values contain opaque binary strings
#   * MSet - Match Set. A page (offset and count) of matches to a query.
#
# IMAP
# ----
#
# IMAP4r1: rfc2060, updated by 3501
# IDLE command: rfc2177
# Namespace: rfc2342
# CONDSTORE: rfc 4551 (multiple connection synchronization and date/sequence
#     based metadata updates. E.G. you can query which messages have changed
#     flags since last query)
# BINARY: rfc 3516 (fetch BINARY vs fetch BODY, saves on base64 encoding
#     transfers, for example.)
# COMPRESS: rfc 4978
#
#

# standard stuff
import os
import sys
import re
import threading
from functools import wraps
# xapian search engine
import xapian
# various email helpers
import imaplib
imaplib._MAXLINE *= 10
import email
import mailbox
# password prompter
import getpass
# Password manager
import keyring
# Configuration and other directory management
import xdg.BaseDirectory
# shell helper
import cmdprompt
# Date handler
import dateutil.parser
import tempfile

confFile = xdg.BaseDirectory.load_first_config("linsam.homelinux.com","mailnex","mailnex.conf")

class Context(object):
    def __init__(self):
        object.__init__(self)
        self.connection = None

class nodate(object):
    """Stand-in for date objects that aren't dates"""
    def strftime(self, _):
        """Display conversion for non-dates.

        Shows question marks no matter what you ask for.
        """
        return "??"
    def astimezone(self, _):
        return self
    tzinfo="??"

# Some decorators
def needsConnection(func):
    @wraps(func)
    def needsConnectionWrapper(self, *args, **kwargs):
        if not self.C.connection:
            print("no connection")
        else:
            return func(self, *args, **kwargs)
    return needsConnectionWrapper

def shortcut(name):
    """Marks a function as having a shortcut.

    Actually, we'll just passthrough right now. This will just document intent for now.

    Eventually, we can add implementation without going through all the functions again to add it."""
    def wrap1(func):
        @wraps(func)
        def shortcutWrapper(self, *args, **kwargs):
            return func(self, *args, **kwargs)
        return shortcutWrapper
    return wrap1

def unpackStruct(data, depth=1, value="", predesc=""):
    """Recursively unpack the structure of a message (as given by IMAP's BODYSTRUCTURE message-data)

    @param data hierarchy of BODYSTRUCTURE elements
    @depth starting depth (may be used for indenting output, or for debugging)
    @value current identifier of parent. For the first call, this should be the message ID. It will be dot separated for sub parts.
    @predesc prefix description. Mostly used internally for when we hit a message/rfc822.
    """
    # This is slightly tricky because of the way they ordered it. I haven't
    # read every revision of IPMI, so I'm guessing this is the result of
    # attempting backwards compatibility as the spec grew.
    #
    # At any given layer, the first element is either a string indicating the
    # MIME type, or it is a parenthesized list describing a sub part.
    # If it is a parenthesized list for a subpart, then there are 1 or more of
    # these (a multipart apparently cannot be empty?), followed by a string of
    # the multipart subtype, then the multipart extension data elements: body
    # parameter list, disposition, language, and location (a URI)
    #
    # If it is a string, then the fields are type, subtype, mime attr list,
    # body id, disposition, encoding and size, followed by type-specific
    # extensions followed by regular extensions.
    #
    # text/* has encoded line count (not decoded; beware of this, it makes it
    # less than useful for showing a line count of what the user will see,
    # though it might be a good way to estimate it.
    #
    # message/rfc822 has envelope structure, body structure, line count
    #
    # Regular extensions are md5, disposition, language, and location (URI).
    #
    # Note that the envelope structure and body structure for message/rfc822
    # is the same format as would be retrieved with a fetch ENVELOPE or fetch
    # BODYSTRUCTURE. In particular, that means that for message/rfc822, we
    # don't recurse on the non-string initial list, but on the body structure
    # element at index 8
    extra = ""
    if isinstance(data[0], list):
        # We are multipart
        for i in range(len(data)):
            if not isinstance(data[i], list):
                break
        if data[i + 2] and data[i + 2][0] and data[i + 2][0] == "attachment":
            extra = " (attachment)"
        elif data[i + 2] and data[i + 2][0] and data[i + 2][0] == "inline":
            extra = " (inline)"
        print("%s   %s%s/%s%s" % (value, predesc, "multipart", data[i], extra))
        j = 1
        for dat in data[:i]:
            unpackStruct(dat, depth + 1, value + '.' + str(j))
            j += 1
    else:
        # If we are message/rfc822, then we have further subdivision!
        if data[0].lower() == "message" and data[1].lower() == "rfc822":
            if data[11] and data[11][0] and data[11][0] == "attachment":
                extra = " (attachment)"
            elif data[11] and data[11][0] and data[11][0] == "inline":
                extra = " (inline)"
            unpackStruct(data[8], depth + 1, value, "message/rfc822%s, which is " % (extra))
        else:
            if data[0].lower() == "text":
                if data[9] and data[9][0] and data[9][0] == "attachment":
                    extra = " (attachment)"
                elif data[9] and data[9][0] and data[9][0] == "inline":
                    extra = " (inline)"
            else:
                if data[8] and data[8][0] and data[8][0] == "attachment":
                    extra = " (attachment)"
                elif data[8] and data[8][0] and data[8][0] == "inline":
                    extra = " (inline)"
            print("%s   %s%s/%s%s" % (value, predesc, data[0], data[1], extra))

def normalizeFetch(data):
    """Re-listize fetch results.

    python standard imaplib (at least in python 2.7) has a hard-to-fathom way
    to represent results, especially when the results include literal data.

    This function attempts to re-structure the results into a sane enough
    array that processAtoms() can handle it.
    """
    # Idea here is that continuation data starts with a space. I hope.
    # example from fetching envelope data from two messages, 898 and 899. 898
    # has some literal data. I've obscured and redacted some stuff for
    # clarity.
    #
    # r = [
    #   (
    #     '898 (ENVELOPE ("date" {81}',
    #     'Subject that is 81 bytes long'
    #   ),
    #   ' ((address)) ((address)) ((etc..)) NIL NIL "messageid" "messageid")),
    #   '899 (ENVELOPE ("date" "Subject" ((addr)) ((addr)) ((etc...)) NIL NIL NIL "messageid"))'
    # ]
    #
    # As can be seen, message 898's data is spread across r[0][0], r[0][1],
    # and r[1]. Message 899's data is in r[2].
    #
    # Without knowing a-priori that 898 had a literal in it, it is impossible
    # just to know where the second requested result is (you'd expect 898 in
    # r[0] and 899 in r[1] and not expect there to even be an r[2]).
    res = []
    for i in range(len(data)):
        if isinstance(data[i], str):
            if data[i][0] == ' ':
                res[-1] += data[i]
            else:
                res.append(data[i])
        else:
            # NOTE: This isn't good; we have probable data loss. It is unknown
            # if the literal should have had a \r or \n or \r\n in it,
            # assuming imaplib messed it up. We really should do our own
            # implementation.
            res.append("\n".join(data[i]))
    return res

def processAtoms(text):
    """Process a set of IMAP ATOMs

    ATOMs are roughly space separated text that can be quoted and can contain
    lists of other atoms by wrapping in parenthses

    According to the RFC:
        Data can be an atom, number, string, parenthesized list, or NIL.
        An atom consists of one or more non-special characters.
        A number consists of digits
        A string is either literal (has a length in braces followed, followed
        by CRLF by data of that length) or quoted (surrounded by double
        quotes)
        A parenthesized list is a nesting structure for all of the data
        formats.
        NIL is like C's NULL or Python's None. Indicates absense of a
        parameter, distinct from an empty string or empty list.

        The special characters that aren't allowed in atoms are parenthesis,
        open curly brace, space, control characters (0x00-0x1f and 0x7f),
        list-wildcards (percent and asterisk), and quoted-specials (double
        quote and backslash).

        In a quote, a backslash provides for denoting a literal. E.g. "\"" is
        a string whose value is a double quote.

    This implementation is currently incomplete. It doesn't handle the \ escape
    in quoted strings, it doesn't interpret literal strings at all, and
    accepts quotes anywhere.
    """


    curlist=[]
    lset=[]
    lset.append(curlist)
    curtext=[]
    inquote = False
    inspace = True
    inbrace = False
    inliteral = False
    literalRemain = 0
    literalSizeString = ""
    skipCrLf = False
    pos = -1
    for c in text:
        pos += 1
        if debug_parse:
            print(" Processing %s" % repr(c))
        if skipCrLf:
            # True or 1 means check the CR of CRLF, then expect the LF of CRLF
            # 2 means expect the LF of CRLF
            if skipCrLf != 2:
                check = '\r'
            else:
                check = '\n'
            if c != check:
                if debug_parse:
                    print("before", repr(text[:pos]))
                    print("at", repr(text[pos]))
                    print("after", repr(text[pos+1:]))
                raise Exception("No crlf where expected (next char was %s)" % repr(c))
            if skipCrLf == 2:
                skipCrLf = False
            else:
                skipCrLf = 2
            continue
        if inliteral:
            curtext.append(c)
            literalRemain -= 1
            if debug_parse:
                print("literal append %s, remaining %i" % (repr(c), literalRemain))
            if literalRemain == 0:
                inliteral = False
                # TODO: Should we assume this completes the token and go back
                # to inspace?
                if debug_parse:
                    print("  Literal complete. Resume normal parsing")
            continue
        if debug_parse:
            print("Processing char", repr(c))
        if c == ' ' or c == '\t':
            if inquote:
                if debug_parse:
                    print(" keep space, we are quoted")
                curtext.append(c)
                continue
            if not inspace:
                if debug_parse:
                    print(" End of token. Append completed word to list:", curtext)
                inspace = True
                curlist.append("".join(curtext))
                curtext=[]
                continue
            continue
        if inbrace and c == '}':
            if debug_parse:
                print("Literal size find:",literalSizeString)
            inbrace = False
            inliteral = True
            skipCrLf = True
            if literalSizeString.isdigit():
                literalRemain = int(literalSizeString)
                if debug_parse:
                    print("Start literal. %i remain" % literalRemain)
                if literalRemain == 0:
                    # Still, skip the CrLf, but don't bother entering the
                    # literal state. Alternative would be to check remail
                    # before appending literal chars above. Neither feels very
                    # clean.
                    inliteral = False
                    # Also, since this is explicitly an empty string (not NIL
                    # for example), go ahead and push it out
                    curlist.append(b"")
                    curtext=[]
                continue
            raise Exception("Invalid literal size %s" % repr(literalSizeString))
        if inspace and c == '{':
            inspace = False
            inbrace = True
            literalSizeString = ""
            continue
        if inbrace:
            literalSizeString += c
            continue
        inspace = False
        if c == '"': #TODO single quote too? -- no.
            if inquote:
                # TODO: Does ending a quote terminate an atom?
                if debug_parse:
                    print(" Leaving quote")
                inquote = False
            else:
                # TODO: Are we allowed to start a quote mid-atom?
                if debug_parse:
                    print(" Entering quote")
                inquote = True
            continue
        if c == '(':
            if inquote:
                if debug_parse:
                    print(" keep paren, we are quoted")
                curtext.append(c)
                continue
            if len(curtext):
                raise Exception("Need space before open paren?")
            if debug_parse:
                print(" start new list")
            curlist=[]
            lset.append(curlist)
            inspace = True
            continue
        if c == ')':
            if inquote:
                if debug_parse:
                    print(" keep paren, we are quoted")
                curtext.append(c)
                continue
            if len(curtext):
                if debug_parse:
                    print(" finish atom before finishing list", curtext)
                curlist.append(b"".join(curtext))
                curtext=[]
            t = curlist
            lset.pop()
            if len(lset) < 1:
                raise Exception("Malformed input. Unbalanced parenthesis: too many close parenthesis")
            curlist = lset[-1]
            if debug_parse:
                print(" finish list", t)
            curlist.append(t)
            inspace = True
            continue
        if debug_parse:
            print(" normal character")
        curtext.append(c)
    if inquote:
        raise Exception("Malformed input. Reached end without a closing quote")
    if len(curtext):
        print("EOF, flush leftover text", curtext)
        curlist.append("".join(curtext))
    if len(lset) > 1:
        raise Exception("Malformed input. Unbalanced parentheses: Not enough close parenthesis")
    if debug_parse:
        print("lset", lset)
        print("cur", curlist)
        print("leftover", curtext)
    return curlist

def processHeaders(text):
    # TODO: Handle \n too?
    lines = text.split('\r\n')
    name = None
    value = ""
    headers = dict()
    for line in lines:
        if line.startswith(" ") or line.startswith("\t"):
            # continuation. Append to previous
            value += "\r\n" + line
            continue
        if name:
            if name not in headers:
                headers[name] = list()
            headers[name].append(value)
        if not ': ' in line:
            if not ':' in line:
                if line == "":
                    # end of headers
                    return headers
                print("I don't like line", repr(line))
            else:
                # poorly formed header, but I've seen it
                name, value = line.split(':', 1)
                name = name.lower()
        else:
            name, value = line.split(': ', 1)
            name = name.lower()
    return headers

class Cmd(cmdprompt.CmdPrompt):
    def help_hidden_commands(self):
        print("The following are hidden commands:")
        print()
        print("  h   -> headers")
        print("  p   -> print")
        print("  q   -> quit")
        print("  x   -> exit")
    def parseMessageList(self, args):
        """Parse a message list specification string into a list of matching message IDs.

        According to the mailx manpage (under "Specifying messages") many
        commands can take a list of message numbers and operate on those
        multiple messages.

        Values can be a space separated list of ranges, or special names. The
        ranges are inclusive. However, if using special names, you cannot give
        multiple.

        E.g.
            5                  -> 5
            5 10               -> 5,10
            5-10               -> 5,6,7,8,9,10
            1-3 5-8 10-12      -> 1,2,3,5,6,7,8,10,11,12
            :u                 -> all unread messages
            1-3 :u             -> invalid specification, though heirloom-mailx equates to just :u
            :u :f              -> invalid specification, heirloom-mailx shows an error

        The resulting list is always in numerical ascending order
            5 3 1 10           -> 1,3,5,10

        The list is in thread/sort order of the message list. Changing the
        sort order likely invalidates the lists.

        As an extension, we'll allow mixing these. I don't see any reason to
        not allow unread messages and also message 5-10, for example. Or a
        list including unread, flagged, and flagged unread messages (":u :f').
        Essentially, the list outside parenthesis is a union. In parenthesis
        is intersection by default (boolean AND) unless using the explicit or
        operator.

        The full list of specials, according to the man page, are:

            :n      All new messages
            :o      All old messages (not read or new)
            :u      All unread messages
            :d      All deleted messages (used in undelete command)
            :r      All read messages
            :f      All flagged messages
            :a      All answered messages (replied)
            :t      All messages marked as draft
            :k      All killed messages
            :j      All junk messages
            .       The current message
            ;       The previously current message (using ; over and over
                    bounces between the last 2 messages)
            ,       The parent of the current message (looking for the message
                    with the Message-Id matching the current In-Reply-To or
                    last References entry
            -       (hyphen) The next previous undeleted message for regular
                    commands or the next previus deleted message for undelete.
            +       The next undeleted message, or the next deleted message
                    for undelete.
            ^       The first undeleted message, or first deleted for the
                    undelete command.
            $       The last message
            &x      The message 'x' and all messages from the thread that
                    begins at it (in thread mode only). X defaults to '.' if
                    not given.
            *       (asterisk) All messages.
            `       (back tick) All messages listed in the previous command
            /str    All messages with 'str' in the subject field, case
                    insensitive (ASCII). If empty, use last search "of that
                    type", whatever that means
            addr    Messages from address 'addr', normally case sensitive for
                    complete email address. Some variables change the
                    processing.
            (cri)   Messages matching an IMAP-style SEARCH criterion.
                    Performed locally if necesary, even when not on IMAP
                    connections.  if 'cri' is empty, reuse last search.

        (cri) is a complicated beasty, see the full documentation for details (from mailx until we have our own).

        Some commands don't take a list, but set the list. For example, the
        implicit command only prints one message (usually the next message).
        When using the back-tick, it will start with the first message in the
        last list, and reset the list. A subsequent run of back tick selects
        the second message, but maintains the list. The next back tick run
        shows the third, and so on.

        We note that there might be additional criteria someone might want to
        assign a shortcut to (for example, some IMAP servers support custom
        flags or labels/tags for messages to help organize them), and only 10
        of the 26 letters of the ASCII alphabet are used, and none of the
        uppercase letters are used. For that matter, nothing stops us from
        using whole words after the ':'. heirloom-mailx only pays attention to
        the first letter (e.g. :uf is interpreted as :u, :fu is interpreted as
        :f). So, we'll support single letters for user shortcuts and full
        words for tag names. This can lead to ambiguity if you have a tag
        named by a single letter. My inclination is to allow the names to be
        quoted.

        In a similar vein, we'd like to be able to have saved lists, akin to
        Vim registers or marks. Since mailx already uses '`' to reference the
        last list, we'll use `x to reference named list x. For simplicity, we
        should keep the lists volatile (switching the active mailbox clears
        all lists). Some issues to resolve with having saved lists persist is
        handling changes to the mailbox. Even keeping it volatile, the mailbox
        IDs can change on us (e.g. another client deleting a message).
        Ideally, we'd detect this and correct the numbers in the list to keep
        track (while watching a box), and remove entries from the list that
        are no longer in the box. For persistent lists, we'd probably have to
        key on UIDs and wipe lists with non-matching UIDVALIDITY. No idea how
        to handle this for local or pop boxes. Probably easiest to not support
        that (everyone should run an IMAP server, even just to export their
        own mail! j/k, but only somewhat).

        Now, this actually breaks compatibility with heriloom-mailx, which
        interprets tokens after the `.

        For example, if we do 'f^$' (and message 6337 happens to be the last
        message), then the list becomes 1,6337.
        If we then do 'f`4', the list becomes 1,4,6337.

        However, if we then do 'f`test@example.com', it tells us there aren't
        any messages form test@example.com.
        But, then if we do 'f test@example.com', it will list the messages
        from test and set the new list. Odd.

        I'm hoping noone relies on this behavior in their workflow, but
        perhaps we should have a setting to use something resembling the old
        behavior. I doubt I could spec the actual old behavior outside of the
        actual program code that interpreted it.
        """

        s=set()
        # Second pass, read a few specials 
        if args == ":u":
            data = self.C.connection.search("UTF-8", "unseen")
            print(data)
            return map(int, data)
        if args == ":f":
            data = self.C.connection.search("UTF-8", "flagged")
            print(data)
            return map(int, data)
        # First pass, lets just handle numbers.
        for r in args.split():
            # Note, we won't be able to keep the simple split once we include
            # quoting and parenthesis
            if '-' in r:
                r2 = r.split('-')
                if len(r2) != 2:
                    raise Exception("Invalid range '%s'" % r)
                s=s.union(range(int(r2[0]), int(r2[1]) + 1))
            else:
                s.add(int(r))

        return list(s)

    
    def default(self, args):
        c,a,l = self.parseline(args)
        #TODO Simulate the tokenizer of mailx a bit better. For example,
        # 'print5' will print message 5 instead of erroring that 'print5'
        # isn't a command.
        if c == 'h':
            #TODO: process shortcuts/aliases/whatever
            return self.do_headers(a)
        elif c[0] == 'h' and not c[1].isalpha():
            return self.do_headers(c[1:] + ' ' + a)
        elif c == 'f':
            return self.do_from(a)
        elif c[0] == 'f' and not c[1].isalpha():
            return self.do_from(c[1:] + ' ' + a)
        elif c == 'p':
            return self.do_print(a)
        elif c == 'q':
            return self.do_quit(a)
        elif c == 'x':
            return self.do_exit(a)
        elif c == 'EOF':
            # Exit or Quit? Maybe make it configurable? What does mailx do?
            print
            return self.do_exit(a)
        elif args.isdigit():
            self.C.currentMessage = int(args)
            self.do_print("")
            self.C.lastcommand=""
        else:
            print("Unknown command", c)
    def emptyline(self):
        # repeat/continue last command
        if self.C.lastcommand=="search":
            self.C.lastsearchpos += 10
            self.do_search(self.C.lastsearch, offset=self.C.lastsearchpos)
        else:
            # Next message
            # TODO: mailx has a special case, which is when it picks the
            # message, e.g. when opening a box and it picks the first
            # flagged or unread message. In which case, the implicit
            # "next" command shows the message marked as current.
            #
            # Plan: Have both currentMessage and nextMessage. Typically
            # they are different, but can be the same.
            #
            # TODO: extension to mailx: Next could mean next in a list;
            # e.g. a saved list or results of f/search command or custom
            # list or whatever.
            # Ideally, we'd mention the active list in the prompt. Ideally
            # we'd also list what the implicit command is in the prompt
            # (e.g. next or search continuation)
            if (self.C.currentMessage == self.C.lastMessage):
                print("at EOF")
            else:
                self.C.currentMessage += 1
                self.do_print("")

    def do_testq(self, text):
        try:
            print(processAtoms(text))
        except Exception as ev:
            print(ev)

    def do_maildir(self, args):
        """Connect to the given maildir.

        You should use the folder command once that's working instead.

        This function should eventually dissappear."""
        C = self.C
        if C.connection:
            print("disconnecting")
            C.connection.close()
            C.connection.logout()
            C = None
        try:
            M = mailbox.Maildir(args, None, False)
        except Exception as ev:
            print("Error:", type(ev), ev)
            return
        C.connection = M
        C.currentMessage = 1
        C.lastMessage = len(M) - 1
        print("Opened maildir with %i messages." % len(M))
    def do_connect(self, args):
        """Connect to the given imap host using local username.

        You should use the folder command once that's working instead.

        This function should eventually dissappear."""
        C = self.C
        if C.connection:
            print("disconnecting")
            C.connection.close()
            #C.connection.logout()
            C = None
        print("Connecting to '%s'" % args)
        argss = args.split()
        user = None
        if len(argss) == 2:
            host = argss[0]
            port = int(argss[1])
        elif len(argss) == 1:
            m = None
            if args.startswith("imap://"):
                m = re.match(r'([^@]*@)?([^/]*)(/.*)', args[7:])
                if not m:
                    print("failed to parse")
                    return
                port = 143
            elif args.startswith("imaps://"):
                m = re.match(r'([^@]*@)?([^/]*)(/.*)', args[8:])
                if not m:
                    print("failed to parse")
                    return
                port = 993
            else:
                pass
            if not m:
                host = args
                port = None
            else:
                user, host, box = m.groups()
                if user:
                    # Remove '@' sign
                    user = user[:-1]
                if box:
                    # Remove single leading '/'
                    box = box[1:]
        else:
            raise Exception("Unknown connect format")
        import imap4
        c = imap4.imap4ClientConnection()
        c.debug = imapdebug
        print("WARNING: Certificates aren't checked. Remote host may be spoofed!")
        try:
            c.connect(host, port=port)
            if c.isTls():
                print("Info: Connection already secure")
            else:
                # TODO: if not c.caps, run capability command
                if not c.caps or not 'STARTTLS' in c.caps:
                    print("Remote doesn't claim TLS support; trying anyway")
                print("Info: Startting TLS negotiation")
                c.starttls()
                if c.isTls():
                    print("Info: Connection now secure")
                else:
                    raise Exception("Failed to secure connection!")
            if not user:
                user = getpass.getuser()
            try:
                pass_ =  keyring.get_password("imap://%s" % host, user)
            except RuntimeError:
                pass_ = None
                print("Info: no password managers found; cannot save your password for automatic login")
            if not pass_:
                pass_ = getpass.getpass()
            print("Info: Logging in")
            c.login(user, pass_)
            print("Info: Loggin complete")
            if box:
                c.select(box)
            else:
                c.select()
            print("Info: Mailbox opened")
            self.C.connection = c
            # By default, mailx marks the first unseen or flagged message as
            # the current message.
            if not hasattr(self.C.connection, 'unseen') or not self.C.connection.unseen:
                # IMAP server didn't give us the first unseen message on
                # connect; we'll have to ask for it. It could either be that
                # the server didn't feel like sending one, or there are no
                # messages that are unseen.
                unseen = map(int, self.C.connection.search("utf-8", "UNSEEN"))
            else:
                unseen = [self.C.connection.unseen]
            flagged = map(int, self.C.connection.search("utf-8", "flagged"))
            msgs = sorted(unseen + flagged)
            if debug:
                print(msgs)
            if len(msgs) == 0:
                self.C.currentMessage = 1
            else:
                self.C.currentMessage = msgs[0]
            self.C.lastMessage = c.exists
            if self.C.currentMessage > self.C.lastMessage:
                # This should only really happen when lastMessage is 0, but
                # range checking is probably good anyway.
                self.C.currentMessage = self.C.lastMessage
            if debug:
                print("Current message: %s. Last message: %s" % (self.C.currentMessage, self.C.lastMessage))

        except KeyboardInterrupt:
            print("Aborting connection")
            del s
            return

    @needsConnection
    def do_index(self, args):
        #M = imaplib.IMAP4("localhost")
        #M.login("john", getpass.getpass())
        C = self.C
        M = C.connection
        i = 1
        seen=0

        db = xapian.WritableDatabase(C.dbpath, xapian.DB_CREATE_OR_OPEN)
        termgenerator = xapian.TermGenerator()
        termgenerator.set_stemmer(xapian.Stem("en"))

        while True:
            if i > C.lastMessage:
                break
            try:
                data = M.fetch(i, '(UID BODYSTRUCTURE)')
                #print(typ)
                #print(data)
                # TODO: use BODYSTRUCTURE to find text/plain subsection and fetch that instead of guessing it will be '1'.
                data = M.fetch(i, '(BODY.PEEK[HEADER] BODY.PEEK[1])')
                #print(typ)
                #print(data)
                #print(data[0][1])
                #print("------------ Message %i -----------" % i)
                #print(data[1][1])

                data = processAtoms(data[0][1])

                headers = data[0][1]
                headers = processHeaders(headers)
                print("\r%i"%i, end='')
                sys.stdout.flush()
                doc = xapian.Document()
                termgenerator.set_document(doc)
                if 'subject' in headers:
                    termgenerator.index_text(headers['subject'][-1], 1, 'S')
                if 'from' in headers:
                    for h in headers['from']:
                        # Yes, a message *can* be from more than one person
                        termgenerator.index_text(h, 1, 'F')
                if 'to' in headers:
                    for h in headers['to']:
                        # Yes, a message *can* be from more than one person
                        termgenerator.index_text(h, 1, 'T')
                if 'cc' in headers:
                    for h in headers['cc']:
                        # Yes, a message *can* be from more than one person
                        termgenerator.index_text(h, 1, 'C')
                if 'thread-index' in headers:
                    termgenerator.index_text(headers['thread-index'][-1],1,'I')
                if 'references' in headers:
                    termgenerator.index_text(headers['references'][-1],1,'R')
                if 'in-reply-to' in headers:
                    termgenerator.index_text(headers['in-reply-to'][-1],1,'P')
                if 'message-id' in headers:
                    termgenerator.index_text(headers['message-id'][-1],1,'M')

                termgenerator.index_text(data[0][3])
                # Support full document retrieval but without reference info
                # (we'll have to fully rebuild the db to get new stuff. TODO:
                # store UID and such)
                doc.set_data(data[0][1])
                idterm = u"Q" + str(i)
                doc.add_boolean_term(idterm)
                db.replace_document(idterm, doc)
                i += 1
            finally:
                pass
        print()
        print("Done!")

    @needsConnection
    def do_print(self, args):
        C = self.C
        M = C.connection
        if args:
            try:
                index = int(args)
            except:
                print("bad arguments")
                return
        else:
            index = C.currentMessage
        # Note: when we go to get the body structure, we should do a simple
        # search for text/plain. We *should* walk each level of the body
        # structure and interpret an action for it in constructing the
        # display.
        #
        # For each layer, we must *first* look for a disposition header to see
        # if it should be inline, attachment, or other. If other, assume
        # attachment. If not present, assume inline if it is something we
        # recognize, attachment otherwise.
        #
        # Then, based on what it is, we can continue parsing.
        #
        # NOTE: The main message might have a disposition header, set to
        # attachment. We would display no content, just prompt the user to
        # maybe save the file or explicitly open it. Opening might be tricky
        # for the actual top level, since we don't currently have a way to
        # differentiate the whole message from the primary contents. Maybe do
        # '.0' or something? Similar issue for the multipart containing a
        # message/rfc822 vs the header in the rfc882 itself.
        #
        # So, whenever we have a message/rfc822 (which is implicitly the top
        # layer), check the message headers. Otherwise check the MIME headers.
        # Make sure this is done in the order of hierarchy (example below)
        #
        # Things we know:
        #  * Multipart/mixed: process each sub-part in turn
        #  * Multipart/alternative: Scan for the best type we understand
        #  * Multipart/signed: check signature in second part against message
        #  in first part (unless told not to), then display sig status and
        #  then try to show the first part using above rules (recurse into it)
        #  * text/plain: easy, show the text after undoing transfer encoding
        #  and converting charset to the output device
        #
        # We might in the future know some others (we could probably implement
        # the RFC rich text email format to an extent, though I'm unaware of
        # any MUA that actually generates it. Or maybe we'll do some HTML
        # parsing, who knows?).
        #
        # Example 1:
        #   multipart/mixed
        #     multipart/alternative
        #       text/plain
        #       text/html
        #     text/plain
        #     image/png
        #
        # hit multipart/mixed, walk each child
        #   hit multipart/alternative, search child types for best
        #   presentation (will be text/plain as only one recognized)
        #       render text/plain
        #   hit (outer) text/plain. Render it
        #   hit image/png, show as attachment instead of rendering.
        #
        # If the (outer) text/plain or the alternative were marked as
        # attachment, they'd be not rendered as well. The contents of the
        # alternative would be odd to be marked, but we'd follow that too.
        #
        # If the png is explicitly inlined, we could either try to render it,
        # or mark is as unrenderable, able to be saved, but supposed to be
        # inlined (e.g. it'd act like an attachment, but we shouldn't call it
        # an attachment, since that wasn't the intent)

        if index == 0 or index > self.C.lastMessage:
            print("No applicable messages")
            return

        data = M.fetch(index, '(BODY.PEEK[HEADER] BODY.PEEK[1])')
        parts = processAtoms(data[0][1])
        # Assert parts[0][0] == "BODY.PEEK[HEADER]"
        headers = parts[0][1]
        # TODO: Get content-type of body and convert to TTY, or at least utf-8
        # Options: Can look at the bodystructure to get the encoding (this
        # seems good, since we already will have fetched it to find the
        # text/plain bit anyhow), or we can explicitly fetch the MIME data of
        # a sub-part.
        # The spec is interesting here. In a MIME message, there are headers
        # for the message, and then headers for each part of a multipart. In
        # IMAP, the "HEADER" part specifier for fetch refers to the top-level
        # (overall) message, or to the headers of a message/rfc822 subpart.
        # The "MIME" part specifier refers to the headers for the various
        # parts, but cannot be applied to the overall message.
        # This is actually because the subpart has its own mime headers BEFORE
        # the encapsulated message's headers. (e.g the sub part has a content
        # type of message/rfc822, but *that* message has a header of
        # content-type text/plain or multipart/alternative or whatever.
        #
        # Assert parts[0][2] == "BODY.PEEK[1]"
        body = parts[0][3]
        import subprocess
        s = subprocess.Popen("less", stdin=subprocess.PIPE)
        #s.communicate(headers + body.decode('latin-1').encode('utf-8'))
        content = headers.decode('windows-1252').encode('utf-8')
        content += body.decode('windows-1252').encode('utf-8')
        s.communicate(content)

    @needsConnection
    def do_latest_threads(self, args):
        """Show the latest 10 threads. If given a number, show the thread containing *that* message.

        This is mostly a testing function.

        First pass: only do the thread bit.
        """

        if not args.isdigit():
            print("Sorry, don't support listing last 10 yet. Try giving a message ID instead")
            return
        M = self.C.connection
        index = int(args)
        data = M.fetch(index, '(BODY.PEEK[HEADER])')
        data = processAtoms(data[0][1])
        headers = processHeaders(data[0][1])
        term = None
        if 'thread-index' in headers:
            term = headers['thread-index'][-1]
        elif 'references' in headers:
            #TODO: find out how references is supposed to work
            # For now, guessing that they are in order, so the first entry is
            # the oldest
            term = headers['references'][-1].split(" ")[0]
        elif 'in-reply-to' in headers:
            term = headers['in-reply-to'][-1]
        elif 'message-id' in headers:
            term = headers['message-id'][-1]
        if term is None:
            print("singleton")
        else:
            def disp(data, matches):
                for i in range(len(data)):
                    headers = processHeaders(data[i])
                    #print('#%i id %s from %s to %s subject %s' % (matches[i].docid, headers['message-id'], headers['from'][-1], headers['to'][-1], headers['subject'][-1]))
                    if index == matches[i].docid:
                        marker = '>'
                    else:
                        marker = ' '
                    print('%s#%i from %-20s  subject %s' % (marker, matches[i].docid, headers['from'][-1][:20], headers['subject'][-1]))
            #find the first message
            term = term.strip('<>')
            #print("   Searching 'id:%s'" % term)
            disp(*self.search("id:%s" % term))
            #print("   Searching 'thread:%s'" % term)
            #disp(*self.search("thread:%s" % term))
            #print("   Searching 'ref:%s'" % term)
            #data, matches = self.search("ref:%s" % term)
            data, matches = self.search("ref:%s thread:%s" % (term, term))
            disp(data, matches)

            # TODO: Having found these matches, we ought to check the list of
            # results for additional references and in-reply-tos in case we
            # missed anything. Finally, we should sort by date or similar.
            #
            # The next step for providing somewhat usefull viewing of the
            # thread ought to be stripping off stuff the user's already seen.
            # In particular, we should try to detect pre- and post- quoted
            # text. A difficulty will be in-line responses. Almost impossible
            # will probably be people who inline response with color only
            # where their reply doesn't mark quoted lines (like Outlook)
    @needsConnection
    def do_show(self, args):
        """Show the raw, unprocessed message"""
        C = self.C
        M = C.connection
        if args:
            try:
                index = int(args)
            except:
                print("bad arguments")
                return
        else:
            index = C.currentMessage
        if index == 0 or index > self.C.lastMessage:
            print("No applicable messages")
            return
        data = M.fetch(index, '(BODY.PEEK[HEADER] BODY.PEEK[TEXT])')
        parts = processAtoms(data[0][1])
        headers = parts[0][1]
        body = parts[0][3]
        #content = headers.encode('utf-8') + body.encode('utf-8')
        content = str(headers) + str(body)
        import subprocess
        s = subprocess.Popen("less", stdin=subprocess.PIPE)
        s.communicate(content)

    def do_mail(self, args):
        """Compose and send a message"""
        # TODO: Completion of email addresses
        if args:
            to = args
        else:
            to = self.singleprompt("To: ")
        # Default is space separated:
        to = to.split()
        subject = self.singleprompt("Subject: ")
        return self.editMessage(to, subject, "")

    def editMessage(self, to, subject, messageText):
        while True:
            try:
                # TODO: allow tabs in the input
                line = self.singleprompt("")
                # TODO: Allow ctrl+c to abort the message, but not mailnex
                # (e.g. at this stage, two ctrl+c would be needed to exit
                # mailnex. The first to abort the message, the second to exit
                # mailnex)
            except EOFError:
                line = '.'
            if line.startswith("~~"):
                # User wants to start the line with a tidle
                messageText += line[1:] + '\r\n'
            elif line.startswith("~h"):
                print("""  Help:
                    ~~ Text -> ~ Text   (enter a line starting with a single '~' into the message)
                    .          Send message
                    ~.         Send message
                    ~q         Quit composing. Don't send. Append message to ~/dead.letter, unless 'drafts' is set.
                    ~x         Quit composing. Don't send. Discard current progress.
                    """)
                # ~!command    = execute shell command
                # ~.           = same as end-of-file indicator (according to mailx)
                #                I feel like it ought to be to insert a literal dot. I can't find a way
                #                to do that in mailx. Maybe a setting to switch between the two operations?
                # ~<file       = same as ~r
                # ~<!command   = run command in shell, insert output into message
                # ~@           = edit attachment list
                # ~@ filename  = add filename to attachment list. Space separated list (according to mailx)
                # ~A           = insert string of the Sign variable (like '~i Sign)
                # ~a           = insert string of the sign variable (like '~i sign)
                # ~bname       = add names to bcc list (space separated)
                # ~cname       = add names to cc list (space separated)
                # ~d           = read ~/dead.letter into message
                # ~e           = edit current message in editor (default is ed?)
                # ~fmessage    = read messages (message ids) into message (or current message if none given). use format of print, but only include first part
                # ~Fmessage    = like ~f, but include all headers and mime parts
                # ~h           = edit headers (to, cc, bcc, subject)
                # ~H           = edit headers (from, reply-to, sender, organization). Once this command is used, ignore associated user settings
                # ~ivar        = insert value of variable into message.
                # ~mmessages   = read message like ~f, but include indentation.
                # ~Mmessages   = like ~m, but include all headers and MIME parts
                # ~p           = print message collected so far, prefaced by headers and postfixed by the attachment list. May be piped to pager.
                # ~q           = abort message, write to dead.letter IF 'save' is set.
                # ~rfile       = read file into message
                # ~sstring     = set subject to string
                # ~tname       = add names to To list (space separated) (direct recipient list)
                # ~v           = invoke alternate editor (VISUAL)
                # ~wfile       = write message to named file, appending if file exists TODO: Have a setting which fails if file exists (mailx doesn't write headers regardless of editheaders setting)
                # ~x           = like ~q, but don't save no matter what.
                # ~|command    = pipe message through shell command as a filter. Retain original if no output.
                # ~:command    = run our command (mailnex)
                # ~_command    = same as ~:
                # ~~string     = insert string prefixed by one '~'
                #
                #
            elif line == "." or line.startswith("~."):
                # Send message
                break
            elif line.startswith("~q"):
                if 'drafts' in self.C.settings:
                    print("Sorry, drafts setting is TBD")
                # TODO: Handle errors here. We want to try hard to not lose
                # the user's message if at all possible.
                ofile = open("%s/dead.letter" % os.environ['HOME'], "a")
                # This is probably not the right format for dead.letter
                ofile.write("From user@localhost\r\nTo: %s\r\nSubject: %s\r\n\r\n%s\r\n" % (to, subject, messageText))
                return
            elif line.startswith("~x"):
                print("Message abandoned")
                return
            elif line.startswith("~v"):
                f=tempfile.mkstemp()
                #TODO: If editHeaders is set, also save the headers
                os.write(f[0], messageText)
                res = os.system("vim %s" % f[1])
                if res != 0:
                    print("Edit aborted; message unchanged")
                else:
                    os.lseek(f[0], 0, os.SEEK_SET)
                    fil = os.fdopen(f[0])
                    messageText = fil.read()
                    del fil
                    os.close(f[0])
                    os.unlink(f[1])
                    #TODO: If editHeaders is set, retrieve those headers
            # TODO: The other ~* functions from mailx.
            # TODO: Extension commands. E.g. we might want "~save <path>" to
            # save a copy of the message to the given path, but keep editing.
            # We definitely want a way to edit an attachment (properties and
            # contents), and to add/edit arbitrary message parts. Should be
            # able to mark parts for signing, encryption, compression, etc.
            else:
                messageText += line + '\r\n'

        # TODO: Actually send the message
        print("Message\nTo: %s\nSubject: %s\n\n%s" % (to, subject, messageText))


    @needsConnection
    def do_mheader(self, args):
        C = self.C
        M = C.connection
        if 0 and args:
            try:
                index = int(args)
            except:
                print("bad arguments")
                return
        else:
            index = C.currentMessage
        res, data = M.fetch(args, '(BODY.PEEK[HEADER])')
        #print(data)
        #print(data[0][1])
        #print()
        #print()
        #print(data)
        headers = processHeaders(data[0][1])
        if "subject" in headers:
            print("Subject:", headers["subject"][-1])
        if "date" in headers:
            print("Date:", headers["date"][-1])
        if "from" in headers:
            print("From:", headers['from'][-1])

        print()
        for key,val in headers.iteritems():
            for i in range(len(val)):
                print("%s[%i]=%s" % (key, i, repr(val)))

    @needsConnection
    def do_structure(self, args):
        C = self.C
        M = C.connection
        if args:
            try:
                index = int(args)
            except:
                print("bad arguments")
                return
        else:
            index = C.currentMessage
        data = M.fetch(index, '(BODYSTRUCTURE)')
        #print(data)
        for entry in data:
            #print(entry)
            try:
                # We should get a list of the form (ID, DATA)
                # where DATA is a list of the form ("BODYSTRUCTURE", struct)
                # and where struct is the actual structure
                d = processAtoms(entry[1])
                val = str(entry[0])
                d = d[0]
            except Exception as ev:
                print(ev)
                return
            if d[0] != "BODYSTRUCTURE":
                print("fail?")
                print(d)
                return
            unpackStruct(d[1], value=val)

# 254 area is interesting; actually uses literals :-/

    #def complete_headers(self, *args):
        #print(" complete_headers", args)
        # Args are 'word', 'line', word start, cursor (I *think*)
        #return ['meh', 'stuff']
    @shortcut("h")
    @needsConnection
    def do_headers(self, args):
        """List headers around the current message. (h for short)"""
        # heirloom-mailx says that it gives 18-message groups, but actually
        # shows about how many will fit on the active terminal.
        # It also says that a '+' argument shows the next 18 message group and
        # '-' shows the previous group. In practice, I've only seen '-' work,
        # and then only if the first message in the group is the active one
        # (otherwise '-' re-lists with the first message selected). I suspect
        # '+' will show the next group *if* the last message in the group is
        # the active one, but I haven't tested.
        C = self.C
        M = C.connection
        if (args):
            # TODO: Support any message nomenclature. In particular, '-'
            if args == '$':
                C.currentMessage = C.lastMessage
            elif not args.isdigit():
                print("Bad parms")
                return
            else:
                C.currentMessage = int(args)
        rows = 25 # TODO get from terminal
        start = (C.currentMessage - 1) // rows * rows
        # alternatively, start = C.currentMessage - (C.currentMessage % rows)
        start += 1 # IMAP is 1's based
        last = start + rows - 1
        if (args):
            # mailx has this behaviour where specifying a location causes the
            # current message to become the first message in the list of
            # headings that contains the requested message. It is a bit
            # confusing, but it is expected by long-time (and medium time)
            # users.
            C.currentMessage = start
        if last > C.lastMessage:
            last = C.lastMessage
        if last == 0:
            print("No applicable messages")
            return
        self.showHeaders("%i:%i" % (start, last))
    def showHeaders(self, messageList):
        data = self.C.connection.fetch("%s" % messageList, "(ENVELOPE)")
        #data = normalizeFetch(data)
        for d in data:
            try:
                d = (d[0], processAtoms(d[1]))
            except Exception as ev:
                print("  %s  (error parsing envelope!)" % d[0], ev)
                continue
            try:
                num = int(d[0])
                datestr = d[1][0][1][0]
                if datestr == 'NIL':
                    date = nodate()
                else:
                    try:
                        date = dateutil.parser.parse(datestr)
                    except ValueError:
                        print("Couldn't parse date string", datestr)
                        date = nodate()
                    if date.tzinfo is None:
                        date = date.replace(tzinfo = dateutil.tz.gettz(self.C.settings['defaultTZ']))
                    # TODO: Make setting for local or original timezone. Or
                    # perhaps better, make it part of the headline setting so if
                    # the user wants, they can see both.
                    date = date.astimezone(dateutil.tz.tzlocal())
                subject = d[1][0][1][1]
                this = True if (num == self.C.currentMessage) else False
                print("%(this)s %(num)4s %(date)19s %(subject)s" % {
                    'this': '>' if this else ' ',
                    'num': num,
                    'date': date.strftime("%04Y-%02m-%02d %02H:%02M:%02S"),
                    'subject': subject,
                    }
                    )
            except Exception as ev:
                print("  %s  (error displaying because '%s'. Data follows)" % (d[0], ev), repr(d))

    @shortcut("f")
    @needsConnection
    def do_from(self, args):
        """List messages (like headers command) for given message list only."""
        # I originally thought 'f' was short for 'find' or something like
        # that. As near as I can guess, earlier implementations of mailx
        # (mail?) took only the straight email address method of selecting
        # message list. Later others were added, but the name was fixed.
        C = self.C
        M = C.connection
        res = self.parseMessageList(args)
        if len(res) == 0:
            print("No matches")
            return
        self.showHeaders("%s" % ",".join(map(str,res)))
    @needsConnection
    def do_namespace(self, args):
        C = self.C
        M = C.connection
        res,data = M.namespace()
        #print(res)
        try:
            data = processAtoms(data[0])
        except Exception as ev:
            print(ev)
            return
        print("Personal namespaces:")
        for i in data[0]:
            print(i)
        print("Other user's namespaces:")
        for i in data[1]:
            print(i)
        print("Shared namespaces:")
        for i in data[2]:
            print(i)

    def search(self, terms, offset=0, pagesize=10):
        C = self.C
        dbpath = C.dbpath
        db = xapian.Database(dbpath)

        queryparser = xapian.QueryParser()
        queryparser.set_stemmer(xapian.Stem("en"))
        queryparser.set_stemming_strategy(queryparser.STEM_SOME)
        queryparser.add_prefix("subject", "S")
        queryparser.add_prefix("from", "F")
        queryparser.add_prefix("to", "T")
        queryparser.add_prefix("cc", "C")
        queryparser.add_prefix("thread", "I")
        queryparser.add_prefix("ref", "R")
        queryparser.add_prefix("prev", "P")
        queryparser.add_prefix("id", "M")
        queryparser.add_prefix("date", "D")
        queryparser.set_database(db)
        query = queryparser.parse_query(terms, queryparser.FLAG_BOOLEAN | queryparser.FLAG_WILDCARD)
        enquire = xapian.Enquire(db)
        enquire.set_query(query)
        matches = []
        data = []
        for match in enquire.get_mset(offset, pagesize):
            fname = match.document.get_data()
            data.append(fname)
            matches.append(match)

        #print(data[0])
        return data, matches
    def do_search(self, args, offset=0, pagesize=10):
        C = self.C
        C.lastsearch = args
        C.lastsearchpos = offset
        C.lastcommand="search"
        data, matches = self.search(args, offset, pagesize)
        for i in range(len(data)):
            fname = data[i]
            match = matches[i]
            fname = fname.split('\r\n')
            fname = filter(lambda x: x.lower().startswith("subject: "), fname)
            if len(fname) == 0:
                fname = "(no subject)"
            else:
                fname = fname[0]
            print(u"%(rank)i (%(perc)3s %(weight)s): #%(docid)3.3i %(title)s" % {
                    'rank': match.rank + 1,
                    'docid': match.docid,
                    'title': fname,
                    'perc': match.percent,
                    'weight': match.weight,
                    }
                    )

    def do_quit(self, args):
        # TODO: Synchronize and quit
        return True

    def do_exit(self, args):
        # TODO: Disconnect but not synchronize and quit
        return True

def interact():
    cmd = Cmd(prompt="mailnex> ", histfile="mailnex_history")
    C = Context()
    C.dbpath = "./maildb1/" # TODO: get from config file or default to XDG data directory
    C.lastcommand=""
    cmd.C = C
    # Default settings. TODO: Put defaults in a separate dictionary or
    # something, so that if the user 'unset's something, we can fall back on
    # the default instead of breaking
    C.settings = {
            'PAGER': 'internal', # How to display stuff
            'defaultTZ': 'UTC', # What timezone to put email that lacks a zone specifier (which is out of spec, but lots of scripts are poorly written)
            }
    postConfFolder = None
    if confFile:
        # Walk through the config file
        with open(confFile) as conf:
            print("reading conf from", confFile)
            for lineno, line in enumerate(conf, 1):
                if line.strip() == "":
                    # Blank line
                    continue
                elif line.strip().startswith('#'):
                    #print("comment")
                    continue
                elif line.strip().startswith("set "):
                    #print("setting", line.strip()[4:])
                    m = re.match(r' *([^ =]+) *= *(.+)', line[4:])
                    if not m:
                        print("Failed to parse set command in line %i" % lineno)
                        continue
                    key, value = m.groups()
                    C.settings[key] = value
                elif line.strip().startswith("folder "):
                    postConfFolder = line.strip()[7:]
                else:
                    print("unknown command in line %i" % lineno)
    if postConfFolder:
        cmd.do_connect(postConfFolder)
    try:
        cmd.cmdloop()
    except KeyboardInterrupt:
        cmd.do_exit("")
    except Exception as ev:
        if debug:
            raise
        else:
            print("Bailing on exception",ev)

if __name__ == "__main__":
    import sys
    interact()

# 2357
