#!/usr/bin/env python2
# Ubuntu 14.04 doesn't have xapian for python3. Quite possibly other modules
# aren't available as well.
#
# I might have to demarcate Ubuntu 16.04 and CentOS 7 as minimum OSes. Don't
# know *yet* if packages are supported there either.
#
# At any rate, might as well make this module as close to python 3 as possible
# for now, so that once we can change over, it'll be easier.
from __future__ import print_function
from __future__ import unicode_literals

#  Search indexing
#  ---------------
# Terms:
#  * Document - unit of search result. Documents have a 32bit id, data, terms,
#  and values.
#       * Data - binary blob, opaque to the engine. You can put the whole body
#       of a document here, or abstracts, or references to the real thing. For
#       email, this would probably be a message-id and/or mailfolder+UID
#       * terms - queryable data. Links to docuements, sortof. Terms can also
#       be field associated (e.g. sender vs body vs date)
#           * xapian supports mapping a field to multiple field prefixes
#           * We could use that such that To and CC map to recipient, and To,
#           CC, From, etc. map to person, etc.
#           * Check the Xapian conventions ('A' for author, etc) for a default
#           set of prefixes before running with our own.
#       * values - advanced topic for advanced searches 
#           * can be sorting keys
#           * can be weight (document importance)
#           * can be numeric values for range sort (dates come to mind)
#           * Values are stored into a slot between 0x0 and 0xfffffffe
#           * values contain opaque binary strings
#   * MSet - Match Set. A page (offset and count) of matches to a query.
#
# IMAP
# ----
#
# IMAP4r1: rfc2060, updated by 3501
# IDLE command: rfc2177
# Namespace: rfc2342
# CONDSTORE: rfc 4551 (multiple connection synchronization and date/sequence
#     based metadata updates. E.G. you can query which messages have changed
#     flags since last query)
# BINARY: rfc 3516 (fetch BINARY vs fetch BODY, saves on base64 encoding
#     transfers, for example.)
# COMPRESS: rfc 4978
#
#

# standard stuff
import os
import sys
import re
import threading
from functools import wraps
# xapian search engine
import xapian
# various email helpers
import imap4
import email
import email.utils
import email.mime.text
import quopri
import mailbox
# password prompter
import getpass
# Password manager
import keyring
# Configuration and other directory management
import xdg.BaseDirectory
# shell helper
import cmdprompt
# Date handler
import dateutil.parser
# Color and other terminal stuffs
import blessings
# Other
import tempfile
import pyuv
import time
import settings
import subprocess

confFile = xdg.BaseDirectory.load_first_config("linsam.homelinux.com","mailnex","mailnex.conf")

# Enums
ATTR_NEW = 0
ATTR_UNREAD = 1
ATTR_NEWREAD = 2
ATTR_OLD = 3
ATTR_SAVED = 4
ATTR_PRESERVED = 5
ATTR_MBOXED = 6
ATTR_FLAGGED = 7
ATTR_ANSWERED = 8
ATTR_DRAFT = 9
ATTR_KILLED = 10
ATTR_THREAD_START = 11
ATTR_THREAD = 12
ATTR_JUNK = 13

class Context(object):
    def __init__(self):
        object.__init__(self)
        self.connection = None

class nodate(object):
    """Stand-in for date objects that aren't dates"""
    def strftime(self, _):
        """Display conversion for non-dates.

        Shows question marks no matter what you ask for.
        """
        return "??"
    def astimezone(self, _):
        return self
    tzinfo="??"

def getResultPart(part, data):
    """Retrieve part's value from data.

    This is for flat arrays that are really key-value lists.
    e.g.
        [key1, val1, key2, val2, key3, val3...]

    Currently, this is a linear search, case insensitive."""
    part = part.lower()
    for i in range(0,len(data),2):
        if data[i].lower() == part:
            return data[i + 1]
    # Raising an exception because, after an IMAP requiest, not having the key
    # you asked for is an exceptional case, and there isn't a good return
    # value that also couldn't be in the array itself without doing something
    # weird like returning a class or something.
    raise Exception("Part %s not found" % part)

class Envelope(object):
    # Envelope fields:
    #   0 - date
    #   1 - subject
    #   2 - from (list or NIL)
    #   3 - sender (list or NIL)
    #   4 - reply-to (list or NIL)
    #   5 - to (list or NIL)
    #   6 - cc (lis or NIL)
    #   7 - bcc (list or NIL)
    #   8 - in-reply-to
    #   9 - message-id
    #
    #   The elements of 2 through 7 consist of name,
    #   at-domain-list (aka source route; typically NIL), mailbox
    #   name, and host name.
    #   Unless it is a group name; see page 77 of RFC 3501 for
    #   details.
    def __init__(self, date, subject, from_, sender, replyTo, to, cc, bcc, inReplyTo, messageId):
        # Assign each of our arguments to attributes of the same name
        for i in "date subject from_ sender replyTo to cc bcc inReplyTo messageId".split():
            setattr(self, i, locals()[i])
    def print(self):
        for i in "date subject from_ sender replyTo to cc bcc inReplyTo messageId".split():
            print("%s: %s" % (i, getattr(self, i)))


# Some decorators
def needsConnection(func):
    @wraps(func)
    def needsConnectionWrapper(self, *args, **kwargs):
        if not self.C.connection:
            print("no connection")
        else:
            return func(self, *args, **kwargs)
    return needsConnectionWrapper

def shortcut(name):
    """Marks a function as having a shortcut.

    Actually, we'll just passthrough right now. This will just document intent for now.

    Eventually, we can add implementation without going through all the functions again to add it."""
    def wrap1(func):
        @wraps(func)
        def shortcutWrapper(self, *args, **kwargs):
            return func(self, *args, **kwargs)
        return shortcutWrapper
    return wrap1

def argsToMessageList(func):
    """This decorator causes a call to self.parseMessageList on the single (non-self) argument, then calls the real function with the list as a single array parameter or None.

    If no arguments are provided, uses None. This allows a command to distinguish between arguments that produce no patch, and a lack of arguments.

    We could just return the current message when nothing is given, but that would make the updateMessageSelectionAtEnd decorator much harder to implement, since it should unmark on no argument (that is, clear the lastList).

    As well, some commands behave differently with or without an argument. E.g. headers does different selection updates and displays markers differently.
    """
    @wraps(func)
    def argsToMessageListWrapper(self, args):
        if args:
            msglist = self.parseMessageList(args)
        else:
            msglist = None
        return func(self, msglist)
    return argsToMessageListWrapper

def updateMessageSelectionAtEnd(func):
    """This decorator updates message selections after the wrapped function completes, but only if no exception is raised.

    The wrapped function must take a message list as its first non-self parameter. (for example, wrap this with argsToMessageList)

    Most commands select the last message of the message list as the current message and update the previous message to the previously current message, and update the marked message list to be the given message list.
    """
    @wraps(func)
    def updateMessageSelectionAtEnd(self, msglist, *args, **kwargs):
        # First, cache the current message; the command we run might change
        # it, but we need it to update the last message correctly. We'll also
        # use it to restore the current message if the function fails.
        previouslyCurrent = self.C.currentMessage
        try:
            res = func(self, msglist, *args, **kwargs)
        except Exception:
            # First restore the current message if we can, but don't fail if
            # we can't.
            try:
                self.C.currentMessage = previouslyCurrent
            except:
                pass
            # Next pass it on up
            raise
        # We successfully finished (well, didn't have an exception), so
        # update the values
        # However, don't update if the message list was empty
        if msglist is None:
            self.C.lastList = []
        else:
            self.C.lastList = msglist
            if len(msglist):
                self.C.prevMessage = previouslyCurrent
                self.C.currentMessage = msglist[-1]
                #TODO how to handle self.C.nextMessage?
        return res
    return updateMessageSelectionAtEnd

def showExceptions(func):
    """This decorator displays exceptions and returns to normal operation.

    It should only wrap commands, not the functions that commands call, because we cannot know what a
    valid return value would be. It takes do_* argument 'args' only, to reduce the likelihood of
    mis-application. As such, it should probably be the outermost wrapper.

    This will print a short exception unless the debug setting contains the exception flag, in which
    case a full stack trace will be shown."""
    @wraps(func)
    def showExceptionsWrapper(self, args):
        if not hasattr(self.C, "excTrack"):
            self.C.excTrack = True
        if self.C.excTrack:
            self.C.excTrack = False
            topException = True
        else:
            topException = False

        try:
            return func(self, args)
        except Exception as ev:
            if not topException:
                raise
            import traceback
            if not self.C.settings.debug.exception:
                # TODO: Print the exception type hierarchy. E.g.
                # "exceptions.KeyError" instead of just "KeyError", since some
                # modules may define same-named exceptions with different
                # meanings.
                print("Error occurred in command '{}': {}".format(func.__name__.lstrip('do_'), traceback.format_exception_only(type(ev), ev)[-1]))
            else:
                traceback.print_exc()
            print("Warning: mailnex may now be in an inconsistent state due to the above error.")
        if topException:
            self.C.excTrack = True
    return showExceptionsWrapper

class structureRoot(object):
    def __init__(self, tag, type_, subtype):
        object.__init__(self)
        self.tag = tag
        # Make types lower case for case insensitive comparisons elsewhere
        self.type_ = type_.lower()
        self.subtype = subtype.lower()
    def __repr__(self):
        return "<structure %s/%s>" % (self.type_, self.subtype)

class structureMultipart(structureRoot):
    def __init__(self, tag, subtype, parameters, disposition, language, location):
        """Create a multipart entry.

        @param tag name of this part (e.g. 1.5.3 for the third part of the fifth part of the first part)
        @param subtype variant of multipart (e.g. mixed, signed, alternative)
        (others as per IMAP spec)
        """
        structureRoot.__init__(self, tag, "multipart", subtype)
        # parameters
        self.disposition = disposition
        # language
        # location
        self.subs = []
        pass
    def addSub(self, sub):
        assert isinstance(sub, structureRoot), "%s isn't a structureRoot or similar" % type(sub)
        self.subs.append(sub)

class structureLeaf(structureRoot):
    def __init__(self, tag, type_, subtype, attrs, bid, description, encoding, size, *args):
        # Note, if type_=='text', args starts with encoded line count.
        # If type_=="message" and subtype=="rfc822", args starts with
        # envelope, body structure, and line count (see structureMessage
        # instead for this case)
        #
        # All *args end with md5, disposition, language, and location.
        structureRoot.__init__(self, tag, type_, subtype)
        if attrs:
            self.attrs = dictifyList(attrs)
        else:
            self.attrs = attrs
        self.bid = bid # Body ID
        self.description = description
        self.encoding = encoding
        self.size = size # octets of encoded message
        if type_ == "text":
            self.lines, args = args[0], args[1:]
        self.md5, self.disposition, self.language, self.location = args

class structureMessage(structureRoot):
    def __init__(self, tag, type_, subtype, attrs, bid, description, encoding, size, envelope, subStruct, lines, md5, disposition, language, location):
        structureRoot.__init__(self, tag, type_, subtype)
        # attrs
        # bid
        # description
        self.encoding = encoding
        # size
        # envelope
        # substruct (auto-add? ignore?)
        # lines
        # md5
        self.disposition = disposition
        # language
        # location
        self.subs = []
    def addSub(self, sub):
        assert isinstance(sub, structureRoot), "%s isn't a structureRoot or similar" % type(sub)
        self.subs.append(sub)

def unpackStruct(data, options, depth=1, tag="", predesc=""):
    """Recursively unpack the structure of a message (as given by IMAP's BODYSTRUCTURE message-data)

    @param data hierarchy of BODYSTRUCTURE elements
    @depth starting depth (may be used for indenting output, or for debugging)
    @tag current identifier of parent. For the first call, this should be the message ID. It will be dot separated for sub parts.
    @predesc prefix description. Mostly used internally for when we hit a message/rfc822.
    @return array of parts, which may contain array of parts.
    """
    # This is slightly tricky because of the way they ordered it. I haven't
    # read every revision of IPMI, so I'm guessing this is the result of
    # attempting backwards compatibility as the spec grew.
    #
    # At any given layer, the first element is either a string indicating the
    # MIME type, or it is a parenthesized list describing a sub part.
    # If it is a parenthesized list for a subpart, then there are 1 or more of
    # these (a multipart apparently cannot be empty?), followed by a string of
    # the multipart subtype, then the multipart extension data elements: body
    # parameter list, disposition, language, and location (a URI)
    #
    # If it is a string, then the fields are type, subtype, mime attr list,
    # body id, disposition, encoding and size, followed by type-specific
    # extensions followed by regular extensions.
    #
    # text/* has encoded line count (not decoded; beware of this, it makes it
    # less than useful for showing a line count of what the user will see,
    # though it might be a good way to estimate it.
    #
    # message/rfc822 has envelope structure, body structure, line count
    #
    # Regular extensions are md5, disposition, language, and location (URI).
    #
    # Note that the envelope structure and body structure for message/rfc822
    # is the same format as would be retrieved with a fetch ENVELOPE or fetch
    # BODYSTRUCTURE. In particular, that means that for message/rfc822, we
    # don't recurse on the non-string initial list, but on the body structure
    # element at index 8
    extra = ""
    this = None
    if isinstance(data[0], list):
        # We are multipart
        for i in range(len(data)):
            if not isinstance(data[i], list):
                break
        info = data[i:]
        this = structureMultipart(tag, *info)
        if data[i + 2] and data[i + 2][0] and data[i + 2][0] == "attachment":
            extra = " (attachment)"
        elif data[i + 2] and data[i + 2][0] and data[i + 2][0] == "inline":
            extra = " (inline)"
        if options.debug.struct:
            print("%s   %s%s/%s%s" % (tag, predesc, "multipart", data[i], extra))
        j = 1
        for dat in data[:i]:
            this.addSub(unpackStruct(dat, options, depth + 1, tag + '.' + str(j)))
            j += 1
    else:
        # If we are message/rfc822, then we have further subdivision!
        if data[0].lower() == "message" and data[1].lower() == "rfc822":
            this = structureMessage(tag, *data)
            if data[11] and data[11][0] and data[11][0] == "attachment":
                extra = " (attachment)"
            elif data[11] and data[11][0] and data[11][0] == "inline":
                extra = " (inline)"
            this.addSub(unpackStruct(data[8], options, depth + 1, tag, "message/rfc822%s, which is " % (extra)))
        else:
            this = structureLeaf(tag, *data)
            if data[0].lower() == "text":
                if data[9] and data[9][0] and data[9][0] == "attachment":
                    extra = " (attachment)"
                elif data[9] and data[9][0] and data[9][0] == "inline":
                    extra = " (inline)"
            else:
                if data[8] and data[8][0] and data[8][0] == "attachment":
                    extra = " (attachment)"
                elif data[8] and data[8][0] and data[8][0] == "inline":
                    extra = " (inline)"
            if options.debug.struct:
                print("%s   %s%s/%s%s" % (tag, predesc, data[0], data[1], extra))
    return this

def dictifyList(lst):
    # convert to list of key,val pairs, then to dictionary
    # See http://stackoverflow.com/a/1625023/4504704 (answer to
    # http://stackoverflow.com/questions/1624883/alternative-way-to-split-a-list-into-groups-of-n)
    # TODO: Probably possible that there could be duplicate keys. Probably
    # need a custom dictionary to handle that. Might also be handy to store
    # the original case of the key and value.
    return dict(zip(*(iter(map(lambda x: x.lower(),lst)),)*2))

def processAtoms(text, options):
    """Process a set of IMAP ATOMs

    ATOMs are roughly space separated text that can be quoted and can contain
    lists of other atoms by wrapping in parenthses

    According to the RFC:
        Data can be an atom, number, string, parenthesized list, or NIL.
        An atom consists of one or more non-special characters.
        A number consists of digits
        A string is either literal (has a length in braces followed, followed
        by CRLF by data of that length) or quoted (surrounded by double
        quotes)
        A parenthesized list is a nesting structure for all of the data
        formats.
        NIL is like C's NULL or Python's None. Indicates absense of a
        parameter, distinct from an empty string or empty list.

        The special characters that aren't allowed in atoms are parenthesis,
        open curly brace, space, control characters (0x00-0x1f and 0x7f),
        list-wildcards (percent and asterisk), and quoted-specials (double
        quote and backslash).

        In a quote, a backslash provides for denoting a literal. E.g. "\"" is
        a string whose value is a double quote.

    This implementation is currently incomplete. It doesn't handle the \ escape
    in quoted strings, it doesn't interpret literal strings at all, and
    accepts quotes anywhere.
    """


    curlist=[]
    lset=[]
    lset.append(curlist)
    curtext=[]
    inquote = False
    inspace = True
    inbrace = False
    inliteral = False
    literalRemain = 0
    literalSizeString = ""
    skipCrLf = False
    pos = -1
    for c in text:
        pos += 1
        if options.debug.parse:
            print(" Processing %s" % repr(c))
        if skipCrLf:
            # True or 1 means check the CR of CRLF, then expect the LF of CRLF
            # 2 means expect the LF of CRLF
            if skipCrLf != 2:
                check = '\r'
            else:
                check = '\n'
            if c != check:
                if options.debug.parse:
                    print("before", repr(text[:pos]))
                    print("at", repr(text[pos]))
                    print("after", repr(text[pos+1:]))
                raise Exception("No crlf where expected (next char was %s)" % repr(c))
            if skipCrLf == 2:
                skipCrLf = False
            else:
                skipCrLf = 2
            continue
        if inliteral:
            curtext.append(c)
            literalRemain -= 1
            if options.debug.parse:
                print("literal append %s, remaining %i" % (repr(c), literalRemain))
            if literalRemain == 0:
                inliteral = False
                # TODO: Should we assume this completes the token and go back
                # to inspace?
                if options.debug.parse:
                    print("  Literal complete. Resume normal parsing")
            continue
        if options.debug.parse:
            print("Processing char", repr(c))
        if c == ' ' or c == '\t':
            if inquote:
                if options.debug.parse:
                    print(" keep space, we are quoted")
                curtext.append(c)
                continue
            if not inspace:
                if options.debug.parse:
                    print(" End of token. Append completed word to list:", curtext)
                inspace = True
                curlist.append(b"".join(curtext))
                curtext=[]
                continue
            continue
        if inbrace and c == '}':
            if options.debug.parse:
                print("Literal size find:",literalSizeString)
            inbrace = False
            inliteral = True
            skipCrLf = True
            if literalSizeString.isdigit():
                literalRemain = int(literalSizeString)
                if options.debug.parse:
                    print("Start literal. %i remain" % literalRemain)
                if literalRemain == 0:
                    # Still, skip the CrLf, but don't bother entering the
                    # literal state. Alternative would be to check remail
                    # before appending literal chars above. Neither feels very
                    # clean.
                    inliteral = False
                    # Also, since this is explicitly an empty string (not NIL
                    # for example), go ahead and push it out
                    curlist.append(b"")
                    curtext=[]
                continue
            raise Exception("Invalid literal size %s" % repr(literalSizeString))
        if inspace and c == '{':
            inspace = False
            inbrace = True
            literalSizeString = ""
            continue
        if inbrace:
            literalSizeString += c
            continue
        inspace = False
        if c == '"': #TODO single quote too? -- no.
            if inquote:
                # TODO: Does ending a quote terminate an atom?
                if options.debug.parse:
                    print(" Leaving quote")
                inquote = False
            else:
                # TODO: Are we allowed to start a quote mid-atom?
                if options.debug.parse:
                    print(" Entering quote")
                inquote = True
            continue
        if c == '(':
            if inquote:
                if options.debug.parse:
                    print(" keep paren, we are quoted")
                curtext.append(c)
                continue
            if len(curtext):
                raise Exception("Need space before open paren?")
            if options.debug.parse:
                print(" start new list")
            curlist=[]
            lset.append(curlist)
            inspace = True
            continue
        if c == ')':
            if inquote:
                if options.debug.parse:
                    print(" keep paren, we are quoted")
                curtext.append(c)
                continue
            if len(curtext):
                if options.debug.parse:
                    print(" finish atom before finishing list", curtext)
                curlist.append(b"".join(curtext))
                curtext=[]
            t = curlist
            lset.pop()
            if len(lset) < 1:
                raise Exception("Malformed input. Unbalanced parenthesis: too many close parenthesis")
            curlist = lset[-1]
            if options.debug.parse:
                print(" finish list", t)
            curlist.append(t)
            inspace = True
            continue
        if options.debug.parse:
            print(" normal character")
        curtext.append(c)
    if inquote:
        raise Exception("Malformed input. Reached end without a closing quote")
    if len(curtext):
        print("EOF, flush leftover text", curtext)
        curlist.append("".join(curtext))
    if len(lset) > 1:
        raise Exception("Malformed input. Unbalanced parentheses: Not enough close parenthesis")
    if options.debug.parse:
        print("lset", lset)
        print("cur", curlist)
        print("leftover", curtext)
    return curlist

def processHeaders(text):
    # TODO: Handle \n too?
    lines = text.split('\r\n')
    name = None
    value = ""
    headers = dict()
    for line in lines:
        if line.startswith(" ") or line.startswith("\t"):
            # continuation. Append to previous
            value += "\r\n" + line
            continue
        if name:
            if name not in headers:
                headers[name] = list()
            headers[name].append(value)
        if not ': ' in line:
            if not ':' in line:
                if line == "":
                    # end of headers
                    return headers
                print("I don't like line", repr(line))
            else:
                # poorly formed header, but I've seen it
                name, value = line.split(':', 1)
                name = name.lower()
        else:
            name, value = line.split(': ', 1)
            name = name.lower()
    return headers

class Cmd(cmdprompt.CmdPrompt):
    def help_hidden_commands(self):
        print("The following are hidden commands:")
        print()
        print("      -> print next message (usually 'print +' except the first time)")
        print("  h   -> headers")
        print("  p   -> print")
        print("  q   -> quit")
        print("  x   -> exit")
    def parseMessageList(self, args):
        """Parse a message list specification string into a list of matching message IDs.

        According to the mailx manpage (under "Specifying messages") many
        commands can take a list of message numbers and operate on those
        multiple messages.

        Values can be a space separated list of ranges, or special names. The
        ranges are inclusive. However, if using special names, you cannot give
        multiple.

        E.g.
            5                  -> 5
            5 10               -> 5,10
            5-10               -> 5,6,7,8,9,10
            1-3 5-8 10-12      -> 1,2,3,5,6,7,8,10,11,12
            :u                 -> all unread messages
            1-3 :u             -> invalid specification, though heirloom-mailx equates to just :u
            :u :f              -> invalid specification, heirloom-mailx shows an error

        The resulting list is always in numerical ascending order
            5 3 1 10           -> 1,3,5,10

        The list is in thread/sort order of the message list. Changing the
        sort order likely invalidates the lists.

        As an extension, we'll allow mixing these. I don't see any reason to
        not allow unread messages and also message 5-10, for example. Or a
        list including unread, flagged, and flagged unread messages (":u :f').
        Essentially, the list outside parenthesis is a union. In parenthesis
        is intersection by default (boolean AND) unless using the explicit or
        operator.

        The full list of specials, according to the man page, are:

            :n      All new messages
            :o      All old messages (not read or new)
            :u      All unread messages
            :d      All deleted messages (used in undelete command)
            :r      All read messages
            :f      All flagged messages
            :a      All answered messages (replied)
            :t      All messages marked as draft
            :k      All killed messages
            :j      All junk messages
            .       The current message
            ;       The previously current message (using ; over and over
                    bounces between the last 2 messages)
            ,       The parent of the current message (looking for the message
                    with the Message-Id matching the current In-Reply-To or
                    last References entry
            -       (hyphen) The next previous undeleted message for regular
                    commands or the next previus deleted message for undelete.
            +       The next undeleted message, or the next deleted message
                    for undelete.
            ^       The first undeleted message, or first deleted for the
                    undelete command.
            $       The last message
            &x      The message 'x' and all messages from the thread that
                    begins at it (in thread mode only). X defaults to '.' if
                    not given.
            *       (asterisk) All messages.
            `       (back tick) All messages listed in the previous command
            /str    All messages with 'str' in the subject field, case
                    insensitive (ASCII). If empty, use last search "of that
                    type", whatever that means
            addr    Messages from address 'addr', normally case sensitive for
                    complete email address. Some variables change the
                    processing.
            (cri)   Messages matching an IMAP-style SEARCH criterion.
                    Performed locally if necesary, even when not on IMAP
                    connections.  if 'cri' is empty, reuse last search.

        (cri) is a complicated beasty, see the full documentation for details (from mailx until we have our own).

        Some commands don't take a list, but set the list. For example, the
        implicit command only prints one message (usually the next message).
        When using the back-tick, it will start with the first message in the
        last list, and reset the list. A subsequent run of back tick selects
        the second message, but maintains the list. The next back tick run
        shows the third, and so on.

        We note that there might be additional criteria someone might want to
        assign a shortcut to (for example, some IMAP servers support custom
        flags or labels/tags for messages to help organize them), and only 10
        of the 26 letters of the ASCII alphabet are used, and none of the
        uppercase letters are used. For that matter, nothing stops us from
        using whole words after the ':'. heirloom-mailx only pays attention to
        the first letter (e.g. :uf is interpreted as :u, :fu is interpreted as
        :f). So, we'll support single letters for user shortcuts and full
        words for tag names. This can lead to ambiguity if you have a tag
        named by a single letter. My inclination is to allow the names to be
        quoted.

        In a similar vein, we'd like to be able to have saved lists, akin to
        Vim registers or marks. Since mailx already uses '`' to reference the
        last list, we'll use `x to reference named list x. For simplicity, we
        should keep the lists volatile (switching the active mailbox clears
        all lists). Some issues to resolve with having saved lists persist is
        handling changes to the mailbox. Even keeping it volatile, the mailbox
        IDs can change on us (e.g. another client deleting a message).
        Ideally, we'd detect this and correct the numbers in the list to keep
        track (while watching a box), and remove entries from the list that
        are no longer in the box. For persistent lists, we'd probably have to
        key on UIDs and wipe lists with non-matching UIDVALIDITY. No idea how
        to handle this for local or pop boxes. Probably easiest to not support
        that (everyone should run an IMAP server, even just to export their
        own mail! j/k, but only somewhat).

        Now, this actually breaks compatibility with heriloom-mailx, which
        interprets tokens after the `.

        For example, if we do 'f^$' (and message 6337 happens to be the last
        message), then the list becomes 1,6337.
        If we then do 'f`4', the list becomes 1,4,6337.

        However, if we then do 'f`test@example.com', it tells us there aren't
        any messages form test@example.com.
        But, then if we do 'f test@example.com', it will list the messages
        from test and set the new list. Odd.

        I'm hoping noone relies on this behavior in their workflow, but
        perhaps we should have a setting to use something resembling the old
        behavior. I doubt I could spec the actual old behavior outside of the
        actual program code that interpreted it.

        Another issue is that the mailx format precludes math, even though ed
        (supposedly the inspiration for the command line) /does/ allow math,
        and I've found myself wanting it several times in my daily mailx
        usage. For example, if I'm on message 6748, and I remembered seeing
        something in the previous message, I just type '-' and mailx shows me
        the previous message (6747), which is great. When I'm done, I want to
        look at the next message. However, I've already seen 6748, so I want
        to go to 6749. However, to get there I either have to iterate using
        '+' or '' (just pressing enter shows the next message) viewing an
        already viewed message (wasting network and terminal bandwidth, and my
        time), or type the whole message number (6749) which is both a lot of
        numbers and requires me to know the message number I was just at (but
        I've been moving relatively, so I don't know without doing a 'headers'
        command or paying attention to the message header when it printed a
        message to my pager).

        Ideally, I ought to be able to do something like '.+2', or really '.'
        plus or minus any number. However, mailx doesn't recognize the plus
        like that, and the minus is already used for ranges.

        Recognizing the plus shouldn't be hard, but differentiating between a
        ranging hyphen and subtraction is tougher. Our parser either needs to
        differentiate between starting with a dot vs a number (and thus
        disallow straight numerical math, which also might be useful to
        someone for selecting a message), or we need the option to use a
        different range character. IMAP uses a colon (':') for ranging, but
        that can get confusing with the shortcuts (e.g. ':u') without writing
        a smarter parser. Vim uses comma for ranging. This might work, because
        comma currently is used only on its own to refer to the current
        parent, never with another character (e.g. you can't spec the parent
        of a different message (say, message 1234) by doing '1234,' or
        ',1234', though oddly if you try either, mailx finds the comma and
        ignores the number).

        It might also be a bit more intuitive to today's users to use Git's parent
        notation (e.g. the parent of 123 would be 123^ or 123~1). This could
        be fairly convenient for a message that is in reply to multiple
        messages, though I don't know that MIME supports that, because the Git
        notation lets you select which parent (e.g. 123^2 picks the second
        parent). Of course, the caret/circumflex ('^') is already special,
        though tilde ('~') is available.

        Other annoying quirks of mailx:

            :d only works in the undelete command. You cannot list deleted
            messages by doing 'f :d' for example. You cannot display a deleted
            message by using :d or by giving the actual message number. You
            have to undelete it before it is accessible again.
        """

        s=set()
        # Second pass, read a few specials 
        if args == '.':
            return [self.C.currentMessage]
        if args == '+':
            # TODO: boundary check
            return [self.C.currentMessage + 1]
        if args == '-':
            # TODO: boundary check
            return [self.C.currentMessage - 1]
        if args == '`':
            # TODO: print "No previously marked messages" if the list is empty
            return self.C.lastList
        if args == '^':
            return [1]
        if args == '$':
            return [self.C.lastMessage]
        if args == ":u":
            data = self.C.connection.search("UTF-8", "unseen")
            if self.C.settings.debug.general:
                print(data)
            return map(int, data)
        if args == ":f":
            data = self.C.connection.search("UTF-8", "flagged")
            if self.C.settings.debug.general:
                print(data)
            return map(int, data)
        # First pass, lets just handle numbers.
        for r in args.split():
            # Note, we won't be able to keep the simple split once we include
            # quoting and parenthesis
            if '-' in r:
                r2 = r.split('-')
                if len(r2) != 2:
                    raise Exception("Invalid range '%s'" % r)
                s=s.union(range(int(r2[0]), int(r2[1]) + 1))
            else:
                s.add(int(r))

        return sorted(list(s))

    
    def default(self, args):
        c,a,l = self.parseline(args)
        #TODO Simulate the tokenizer of mailx a bit better. For example,
        # 'print5' will print message 5 instead of erroring that 'print5'
        # isn't a command.
        if not c:
            # Sometimes, parseline assumes there are aguments and no commands.
            # E.g. '-' and '$' result in c="", with a and l containing the
            # given string.
            c = l
            a = ''
        if c == 'h':
            #TODO: process shortcuts/aliases/whatever
            return self.do_headers(a)
        elif c[0] == 'h' and len(c) > 1 and not c[1].isalpha():
            return self.do_headers(c[1:] + ' ' + a)
        elif c == 'f':
            return self.do_from(a)
        elif c[0] == 'f' and len(c) > 1 and not c[1].isalpha():
            return self.do_from(c[1:] + ' ' + a)
        elif c == 'p':
            return self.do_print(a)
        elif c == 'q':
            return self.do_quit(a)
        elif c == 'vf':
            return self.do_virtfolder(a)
        elif c == 'x':
            return self.do_exit(a)
        elif c == 'EOF':
            # Exit or Quit? Maybe make it configurable? What does mailx do?
            print
            return self.do_exit(a)
        elif args.isdigit():
            # TODO: Should just try to do a parse of the line, independant of
            # if it looks like digits
            self.C.currentMessage = int(args)
            self.do_print("")
            self.C.lastcommand=""
        else:
            print("Unknown command", c)
    def emptyline(self):
        # repeat/continue last command
        if self.C.lastcommand=="search":
            self.C.lastsearchpos += 10
            self.do_search(self.C.lastsearch, offset=self.C.lastsearchpos)
        else:
            # Next message
            # TODO: mailx has a special case, which is when it picks the
            # message, e.g. when opening a box and it picks the first
            # flagged or unread message. In which case, the implicit
            # "next" command shows the message marked as current.
            #
            # Likewise, after a from command, the current message is used
            # instead of the next.
            #
            # Plan: Have both currentMessage and nextMessage. Typically
            # they are different, but can be the same.
            #
            # TODO: extension to mailx: Next could mean next in a list;
            # e.g. a saved list or results of f/search command or custom
            # list or whatever.
            # Ideally, we'd mention the active list in the prompt. Ideally
            # we'd also list what the implicit command is in the prompt
            # (e.g. next or search continuation)
            if (self.C.nextMessage > self.C.lastMessage):
                print("at EOF")
            else:
                self.C.currentMessage = self.C.nextMessage
                # print will update nextMessage for us
                self.do_print("")

    @showExceptions
    def do_testq(self, text):
        print(processAtoms(text), self.C.settings)

    @showExceptions
    def do_maildir(self, args):
        """Connect to the given maildir.

        You should use the folder command once that's working instead.

        This function should eventually dissappear."""
        C = self.C
        if C.connection:
            print("disconnecting")
            C.connection.close()
            C.connection.logout()
            C = None
        try:
            M = mailbox.Maildir(args, None, False)
        except Exception as ev:
            print("Error:", type(ev), ev)
            return
        C.connection = M
        C.currentMessage = 1
        C.nextMessage = 1
        C.lastMessage = len(M) - 1
        print("Opened maildir with %i messages." % len(M))

    @showExceptions
    def do_folder(self, args):
        """Connect to the given mailbox.

        If argument starts with a '+', the value of setting 'folder' is prepended to the target

        Currently supported protocols:
            imap://     - IMAP4r1 with STARTTLS
            imaps://    - IMAP4r1 over SSL
        """

        C = self.C
        argss = args.split()
        user = None
        proto = None
        if len(argss) == 2:
            host = argss[0]
            port = int(argss[1])
        elif len(argss) == 1:
            if args.startswith("+"):
                args = self.C.settings.folder.value + args[1:]
            m = None
            if args.startswith("imap://"):
                m = re.match(r'([^@]*@)?([^/]*)(/.*)', args[7:])
                if not m:
                    print("failed to parse")
                    return
                port = 143
                proto = 'imap'
            elif args.startswith("imaps://"):
                m = re.match(r'([^@]*@)?([^/]*)(/.*)', args[8:])
                if not m:
                    print("failed to parse")
                    return
                port = 993
                proto = 'imaps'
            else:
                pass
            if not m:
                host = args
                port = None
                box = ""
            else:
                user, host, box = m.groups()
                if user:
                    # Remove '@' sign
                    user = user[:-1]
                if box:
                    # Remove single leading '/'
                    box = box[1:]
        else:
            raise Exception("Unknown connect format")
        if C.connection:
            if (
                    proto == C.connection.mailnexProto and
                    user == C.connection.mailnexUser and
                    host == C.connection.mailnexHost and
                    port == C.connection.mailnexPort
                    ):
                # We can reuse the existing connection
                c = self.C.connection
            else:
                print("disconnecting")
                C.connection.close()
                #C.connection.logout()
                C.connection = None
        if not C.connection:
            print("Connecting to '%s'" % args)
            c = imap4.imap4ClientConnection()
            c.debug = C.settings.debug.imap

            if "cacertsfile_{}".format(host) in self.C.settings:
                c.setCaCerts(getattr(self.C.settings, "cacertsfile_{}".format(host)).value)
            else:
                c.setCaCerts(C.settings.cacertsfile.value)
            # Set tracking info for detecting connection reusability
            c.mailnexProto = proto
            c.mailnexUser = user
            c.mailnexHost = host
            c.mailnexPort = port
            print("WARNING: Certificates are only partially checked. Remote host may be spoofed!")
            try:
                c.connect(host, port=port)
                if c.isTls():
                    print("Info: Connection already secure")
                else:
                    # TODO: if not c.caps, run capability command
                    if not c.caps or not 'STARTTLS' in c.caps:
                        print("Remote doesn't claim TLS support; trying anyway")
                    print("Info: Startting TLS negotiation")
                    c.starttls()
                    if c.isTls():
                        print("Info: Connection now secure")
                    else:
                        raise Exception("Failed to secure connection!")
                if not user:
                    user = getpass.getuser()
                try:
                    pass_ =  keyring.get_password("imap://%s" % host, user)
                except RuntimeError:
                    pass_ = None
                    print("Info: no password managers found; cannot save your password for automatic login")
                if not pass_:
                    pass_ = getpass.getpass()
                print("Info: Logging in")
                c.login(user, pass_)
                print("Info: Loggin complete")
            except KeyboardInterrupt:
                print("Aborting connection")
                self.C.connection = None
                return
            except imap4.ssl.SSLError as ev:
                print("Failed to establish a secure connection:", ev)
                print("Probably the certificate chain couldn't be verified. If you have\n"
                        "a trusted cert or authority for this host, try setting it in\n"
                        "cecertsfile_{}".format(host))
                self.C.connection = None
                return
        try:
            c.clearCB("exists")
            if box:
                c.select(box)
            else:
                c.select()
            print("Info: Mailbox opened")
            self.C.connection = c
            # By default, mailx marks the first unseen or flagged message as
            # the current message.
            # TODO: Actually, I think its the first new message, then flagged.
            if not hasattr(self.C.connection, 'unseen') or not self.C.connection.unseen:
                # IMAP server didn't give us the first unseen message on
                # connect; we'll have to ask for it. It could either be that
                # the server didn't feel like sending one, or there are no
                # messages that are unseen.
                unseen = map(int, self.C.connection.search("utf-8", "UNSEEN"))
            else:
                unseen = [self.C.connection.unseen]
            if len(unseen) != 0:
                self.C.currentMessage = sorted(unseen)[0]
            else:
                flagged = map(int, self.C.connection.search("utf-8", "flagged"))
                if len(flagged) != 0:
                    self.C.currentMessage = sorted(flagged)[0]
                else:
                    # Final fallback: start at beginning.
                    # TODO: There's probably a setting to start at the end
                    self.C.currentMessage = 1
            self.C.lastMessage = c.exists
            c.setCB("exists", self.newExist)
            if self.C.currentMessage > self.C.lastMessage:
                # This should only really happen when lastMessage is 0, but
                # range checking is probably good anyway.
                self.C.currentMessage = self.C.lastMessage
            self.C.nextMessage = C.currentMessage
            if self.C.settings.debug.general:
                # TODO: Maybe we should output this kind of info anyway...
                print("Current message: %s. Last message: %s" % (self.C.currentMessage, self.C.lastMessage))
            self.C.lastList = []
            self.C.virtfolder = None
            self.C.prevMessage = None

        except KeyboardInterrupt:
            print("Aborting")
            return

    def newExist(self, value):
        delta = value - self.C.lastMessage
        self.C.lastMessage = value
        # TODO: We might get this on message expunge as well (e.g. delta would
        # be negative). Might also be the case where this doesn't change value
        # becuase something was added and something else was expunged.
        # Probably need to track untagged fetch results to see that.
        self.cli.run_in_terminal(lambda: print("Info: %s: %i New messages" % (time.asctime(), delta)))
        # TODO: Run these in a libuv callback; doing it now can be problematic
        # (e.g. we are very likely in the middle of some command, like NOOP)
        if self.C.settings.receiptheaders:
            if delta == 1:
                self.cli.run_in_terminal(lambda: self.showHeaders("%i" % value))
            else:
                self.cli.run_in_terminal(lambda: lself.showHeaders("%i:%i" % (value - delta, value)))

    def bgcheck(self, event):
        # NOOP command does nothing, but it has the side effect of allowing
        # the server to send us untagged updates (e.g. new message
        # indications) as well as preventing inactivity timeout.
        # This should be done once every 29 minutes or so (servers are allowed
        # to make their timeout as small as 30 minutes). When not idling, this
        # can be set much quicker to find new mail in a reasonable amount of
        # time.
        if self.C.connection:
            self.C.connection.doSimpleCommand("noop")

    @showExceptions
    @needsConnection
    def do_index(self, args):
        C = self.C
        M = C.connection
        i = 1
        seen=0

        db = xapian.WritableDatabase(C.dbpath, xapian.DB_CREATE_OR_OPEN)
        termgenerator = xapian.TermGenerator()
        termgenerator.set_stemmer(xapian.Stem("en"))

        while True:
            if i > C.lastMessage:
                break
            try:
                data = M.fetch(i, '(UID BODYSTRUCTURE)')
                #print(typ)
                #print(data)
                # TODO: use BODYSTRUCTURE to find text/plain subsection and fetch that instead of guessing it will be '1'.
                data = M.fetch(i, '(BODY.PEEK[HEADER] BODY.PEEK[1])')
                #print(typ)
                #print(data)
                #print(data[0][1])
                #print("------------ Message %i -----------" % i)
                #print(data[1][1])

                data = processAtoms(data[0][1], self.C.settings)

                headers = data[0][1]
                headers = processHeaders(headers)
                print("\r%i"%i, end='')
                sys.stdout.flush()
                doc = xapian.Document()
                termgenerator.set_document(doc)
                if 'subject' in headers:
                    termgenerator.index_text(headers['subject'][-1], 1, 'S')
                if 'from' in headers:
                    for h in headers['from']:
                        # Yes, a message *can* be from more than one person
                        termgenerator.index_text(h, 1, 'F')
                if 'to' in headers:
                    for h in headers['to']:
                        # Yes, a message *can* be from more than one person
                        termgenerator.index_text(h, 1, 'T')
                if 'cc' in headers:
                    for h in headers['cc']:
                        # Yes, a message *can* be from more than one person
                        termgenerator.index_text(h, 1, 'C')
                if 'thread-index' in headers:
                    termgenerator.index_text(headers['thread-index'][-1],1,'I')
                if 'references' in headers:
                    termgenerator.index_text(headers['references'][-1],1,'R')
                if 'in-reply-to' in headers:
                    termgenerator.index_text(headers['in-reply-to'][-1],1,'P')
                if 'message-id' in headers:
                    termgenerator.index_text(headers['message-id'][-1],1,'M')

                termgenerator.index_text(data[0][3])
                # Support full document retrieval but without reference info
                # (we'll have to fully rebuild the db to get new stuff. TODO:
                # store UID and such)
                doc.set_data(data[0][1])
                idterm = u"Q" + str(i)
                doc.add_boolean_term(idterm)
                db.replace_document(idterm, doc)
                i += 1
            finally:
                pass
        print()
        print("Done!")

    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_print(self, msglist):
        C = self.C
        M = C.connection
        lastMessage = len(self.C.virtfolder) if self.C.virtfolder else self.C.lastMessage
        if msglist is None:
            index = C.currentMessage
            if index == 0 or index > lastMessage:
                print("No applicable messages")
                return
            msgs = [index]
        else:
            msgs = msglist

        # Note: when we go to get the body structure, we should do a simple
        # search for text/plain. We *should* walk each level of the body
        # structure and interpret an action for it in constructing the
        # display.
        #
        # For each layer, we must *first* look for a disposition header to see
        # if it should be inline, attachment, or other. If other, assume
        # attachment. If not present, assume inline if it is something we
        # recognize, attachment otherwise.
        #
        # Then, based on what it is, we can continue parsing.
        #
        # NOTE: The main message might have a disposition header, set to
        # attachment. We would display no content, just prompt the user to
        # maybe save the file or explicitly open it. Opening might be tricky
        # for the actual top level, since we don't currently have a way to
        # differentiate the whole message from the primary contents. Maybe do
        # '.0' or something? Similar issue for the multipart containing a
        # message/rfc822 vs the header in the rfc882 itself.
        #
        # So, whenever we have a message/rfc822 (which is implicitly the top
        # layer), check the message headers. Otherwise check the MIME headers.
        # Make sure this is done in the order of hierarchy (example below)
        #
        # Things we know:
        #  * Multipart/mixed: process each sub-part in turn
        #  * Multipart/alternative: Scan for the best type we understand
        #  * Multipart/signed: check signature in second part against message
        #  in first part (unless told not to), then display sig status and
        #  then try to show the first part using above rules (recurse into it)
        #  * text/plain: easy, show the text after undoing transfer encoding
        #  and converting charset to the output device
        #
        # We might in the future know some others (we could probably implement
        # the RFC rich text email format to an extent, though I'm unaware of
        # any MUA that actually generates it. Or maybe we'll do some HTML
        # parsing, who knows?).
        #
        # Example 1:
        #   multipart/mixed
        #     multipart/alternative
        #       text/plain
        #       text/html
        #     text/plain
        #     image/png
        #
        # hit multipart/mixed, walk each child
        #   hit multipart/alternative, search child types for best
        #   presentation (will be text/plain as only one recognized)
        #       render text/plain
        #   hit (outer) text/plain. Render it
        #   hit image/png, show as attachment instead of rendering.
        #
        # If the (outer) text/plain or the alternative were marked as
        # attachment, they'd be not rendered as well. The contents of the
        # alternative would be odd to be marked, but we'd follow that too.
        #
        # If the png is explicitly inlined, we could either try to render it,
        # or mark is as unrenderable, able to be saved, but supposed to be
        # inlined (e.g. it'd act like an attachment, but we shouldn't call it
        # an attachment, since that wasn't the intent)
        #
        # For rendering, the img2txt program (from caca-utils) might be a good
        # option.

        # TODO: Support lists. For now, just handle the first in the list
        index = msgs[0]
        if self.C.virtfolder:
            if index > lastMessage:
                print("Message {} out of range".format(index))
                return
            index = self.C.virtfolder[index - 1]

        data = M.fetch(index, '(BODY.PEEK[HEADER] BODYSTRUCTURE)')
        parts = processAtoms(data[0][1], self.C.settings)
        headers = getResultPart('BODY[HEADER]', parts[0])
        # TODO: Get content-type of body and convert to TTY, or at least utf-8
        # Options: Can look at the bodystructure to get the encoding (this
        # seems good, since we already will have fetched it to find the
        # text/plain bit anyhow), or we can explicitly fetch the MIME data of
        # a sub-part.
        # The spec is interesting here. In a MIME message, there are headers
        # for the message, and then headers for each part of a multipart. In
        # IMAP, the "HEADER" part specifier for fetch refers to the top-level
        # (overall) message, or to the headers of a message/rfc822 subpart.
        # The "MIME" part specifier refers to the headers for the various
        # parts, but cannot be applied to the overall message.
        # This is actually because the subpart has its own mime headers BEFORE
        # the encapsulated message's headers. (e.g the sub part has a content
        # type of message/rfc822, but *that* message has a header of
        # content-type text/plain or multipart/alternative or whatever.
        #
        structstr = getResultPart('BODYSTRUCTURE', parts[0])
        struct = unpackStruct(structstr, self.C.settings, tag=str(index))
        structureStrings = []
        fetchParts = []
        def pickparts(struct):
            """Pick the parts we are going to use to produce a regular view of the message.

            We'll build a visualization of the structure while we are at it (much of
            this code is duplicated from do_structure)"""
            # TODO: unify the code with do_structure? Make its own function?
            # We probably want that anyway since other parts would utilize
            # this, such as message reply/forwarding
            extra = ""
            skip = False
            if hasattr(struct, "disposition") and struct.disposition not in [None, "NIL"]:
                extra += " (%s)" % struct.disposition[0]
                if struct.disposition[0].lower() == "attachment":
                    skip = True
                dispattrs = dictifyList(struct.disposition[1])
                if 'filename' in dispattrs:
                    extra += " (name: %s)" % dispattrs['filename']
            # TODO XXX: Preprocess control chars out of all strings before
            # display to terminal!
            structureStrings.append("%s   %s/%s%s" % (struct.tag, struct.type_, struct.subtype, extra))
            innerTag = ".".join(struct.tag.split('.')[1:])
            # First pass, we'll just grab all text/plain parts. Later we'll
            # want to check disposition, and later we'll want to deal with
            # multipart/alternative better (and multipart/related)
            if struct.type_ == "text" and struct.subtype == "plain":
                # TODO: write the following a bit more efficiently. Like,
                # split only once, use second part of return only, perhaps?
                if not skip:
                    fetchParts.append((innerTag, struct))
            if isinstance(struct, structureMessage):
                extra = ""
                # Switch to the inner for further processing
                struct = struct.subs[0]
                if hasattr(struct, "disposition") and struct.disposition not in [None, "NIL"]:
                    extra += " (%s)" % struct.disposition[0]

                structureStrings.append("%*s   `-> %s/%s%s" % (len(struct.tag), "", struct.type_, struct.subtype, extra))
                fetchParts.append(("%s.HEADER" % innerTag, struct))
            if hasattr(struct, "subs"):
                for i in struct.subs:
                    pickparts(i)
        pickparts(struct)
        structureString = u"\n".join(structureStrings)
        if len(fetchParts) == 0:
            print("Message doesn't have any displayable parts.")
            return
        elif len(fetchParts) == 1 and len(fetchParts[0][0]) == 0:
            # This message doesn't have parts, so fetch "part 1" to get the
            # body
            fparts = ["BODY.PEEK[1]"]
            parts = ["BODY[1]"]
        else:
            fparts = ["BODY.PEEK[%s]" % s[0] for s in fetchParts]
            parts = ["BODY[%s]" % s[0] for s in fetchParts]
        data = M.fetch(index, '(%s)' % " ".join(fparts))
        body = structureString + '\r\n\r\n'
        dpart = processAtoms(data[0][1], self.C.settings)
        for p,o in zip(parts,fetchParts):
            dstr = getResultPart(p, dpart[0])
            if isinstance(o[1], structureMultipart):
                o[1].encoding = None
                o[1].attrs = None
                # TODO: Use terminfo/termcap (or perhaps pygments or
                # prompt_toolkit) for styling
                # Ideally, subparts like attatched messages should be
                # indented, perhaps with a colored bar
                if not self.C.settings.allpartlabels:
                    # Don't show a label here if we are going to show it
                    # anyway below.
                    body += "\n\033[7mPart %s:\033[0m\n" % (o[0])
            if self.C.settings.allpartlabels:
                body += "\n\033[7mPart %s:\033[0m\n" % (o[0])
            encoding = o[1].encoding
            if self.C.settings.debug.general:
                body += "encoding: " + encoding + "\r\n"
                body += "struct: " + repr(o[1].__dict__) + "\r\n"
            # First, check for transfer encoding
            if encoding in [None, "", "NIL", '7bit', '8bit']:
                # Don't need to do anything
                pass
            elif encoding == "quoted-printable":
                dstr = dstr.decode("quopri")
            elif encoding == "base64":
                dstr = dstr.decode("base64")
            else:
                body += "Part %s: unknown encoding %s\r\n" % (o[0], encoding)
                continue
            # Finally, check for character set encoding
            if o[1].attrs and 'charset' in o[1].attrs:
                charset = o[1].attrs['charset']
                try:
                    # TODO: Is this possibly a security risk? Is there any
                    # value that causes the decode function to go awry?
                    d = dstr.decode(charset)
                    # Look for common control characters that likely mean a
                    # decode error. Most common is MS Outlook encoding text in
                    # CP1252 and then claiming it is iso-8859-1.
                    for c in map(chr, range(0x80,0xa0)):
                        if c in d:
                            raise UnicodeDecodeError()
                    body += d
                except:
                    if charset == 'iso-8859-1':
                        # MS Outlook lies about its charset, so we'll try what
                        # they mean instead of what they say. TODO: Should we
                        # complain about this? Not like the user can do much
                        # except encourage the sender to stop using outlook.
                        try:
                            body += dstr.decode('windows-1252')
                        except:
                            body += "Part %s: failed to decode as %s or windows-1252\r\n" % (o[0], charset)
                    else:
                        body += "Part %s: failed to decode as %s\r\n" % (o[0], charset)
            else:
                body += dstr
        # TODO: Headers are required to be ASCII or encoded using a header
        # encoding that results in ASCII (lists charset and encodes as
        # quoted-printable or base64 with framing). We should decode headers
        # to unicode using ASCII and, if failing, replace with highlighted
        # error boxes or something (not question marks, ideally). Then, we
        # should look for the header encoding markers and handle those as
        # well.

        # TODO: Use terminfo/termcap (or perhaps pygments or prompt_toolkit)
        # for styling
        content = b"\033[7mMessage %i:\033[0m\n\n" % index
        content += headers.decode('windows-1252').encode('utf-8')
        content += body.encode('utf-8')
        s = subprocess.Popen(["less","-R"], stdin=subprocess.PIPE)
        s.communicate(content)
        res = s.wait()
        if res == 0:
            # TODO: Allow asynchronous mode. That is, in mailx, we locally
            # keep track of the fact that the message was seen until the user
            # quits (not exits) or selects another folder.
            #
            # I'm pretty sure mailx did it that way because modifying mbox
            # files multiple times is expensive, so it was better for the
            # system to rewrite it once only when exiting. It also isn't
            # expected to have live synchronized access to the box.
            #
            # With IMAP and/or maildir, this isn't the case. Setting flags is
            # cheap (either the IMAP server handles it, or it is a file rename
            # in maildir) and doing it live ensures we don't lose data on a
            # crash *and* allows multiple clients to see updated information
            # as it happens from any client.
            #
            # However, some people probably like the mailx behavior better
            # because they are used to it, so we ought to support it.
            M.doSimpleCommand("STORE %s +FLAGS (\Seen)" % index)
            # Update message stuffs. Should probably update the 'lastList' as
            # well.
            C.nextMessage = C.currentMessage + 1

    @showExceptions
    @needsConnection
    def do_latest_threads(self, args):
        """Show the latest 10 threads. If given a number, show the thread containing *that* message.

        This is mostly a testing function.

        First pass: only do the thread bit.
        """

        if not args.isdigit():
            print("Sorry, don't support listing last 10 yet. Try giving a message ID instead")
            return
        M = self.C.connection
        index = int(args)
        data = M.fetch(index, '(BODY.PEEK[HEADER])')
        data = processAtoms(data[0][1], self.C.settings)
        headers = processHeaders(data[0][1])
        term = None
        if 'thread-index' in headers:
            term = headers['thread-index'][-1]
        elif 'references' in headers:
            #TODO: find out how references is supposed to work
            # For now, guessing that they are in order, so the first entry is
            # the oldest
            term = headers['references'][-1].split(" ")[0]
        elif 'in-reply-to' in headers:
            term = headers['in-reply-to'][-1]
        elif 'message-id' in headers:
            term = headers['message-id'][-1]
        if term is None:
            print("singleton")
        else:
            def disp(data, matches):
                for i in range(len(data)):
                    headers = processHeaders(data[i])
                    #print('#%i id %s from %s to %s subject %s' % (matches[i].docid, headers['message-id'], headers['from'][-1], headers['to'][-1], headers['subject'][-1]))
                    if index == matches[i].docid:
                        marker = '>'
                    else:
                        marker = ' '
                    print('%s#%i from %-20s  subject %s' % (marker, matches[i].docid, headers['from'][-1][:20], headers['subject'][-1]))
            #find the first message
            term = term.strip('<>')
            #print("   Searching 'id:%s'" % term)
            disp(*self.search("id:%s" % term))
            #print("   Searching 'thread:%s'" % term)
            #disp(*self.search("thread:%s" % term))
            #print("   Searching 'ref:%s'" % term)
            #data, matches = self.search("ref:%s" % term)
            data, matches = self.search("ref:%s thread:%s" % (term, term))
            disp(data, matches)

            # TODO: Having found these matches, we ought to check the list of
            # results for additional references and in-reply-tos in case we
            # missed anything. Finally, we should sort by date or similar.
            #
            # The next step for providing somewhat usefull viewing of the
            # thread ought to be stripping off stuff the user's already seen.
            # In particular, we should try to detect pre- and post- quoted
            # text. A difficulty will be in-line responses. Almost impossible
            # will probably be people who inline response with color only
            # where their reply doesn't mark quoted lines (like Outlook)

    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_show(self, msglist):
        """Show the raw, unprocessed message"""
        C = self.C
        M = C.connection
        if msglist is None:
            index = C.currentMessage
            if index == 0 or index > self.C.lastMessage:
                print("No applicable messages")
                return
            msgs = [index]
        else:
            msgs = msglist
        content = b""
        for index in msgs:
            data = M.fetch(index, '(BODY.PEEK[HEADER] BODY.PEEK[TEXT])')
            parts = processAtoms(data[0][1], self.C.settings)
            headers = parts[0][1]
            body = parts[0][3]
            #content = headers.encode('utf-8') + body.encode('utf-8')
            content += "Message {}:\n".format(index) + str(headers) + str(body)
        # TODO: Process content for control chars?
        s = subprocess.Popen("less", stdin=subprocess.PIPE)
        s.communicate(content)

    @showExceptions
    def do_mail(self, args):
        """Compose and send a message"""
        # TODO: Completion of email addresses
        if args:
            to = args
        else:
            # TODO: Support completions from, e.g. Khard
            to = self.singleprompt("To: ")
        # Default is space separated:
        to = to.split()
        subject = self.singleprompt("Subject: ")
        newmsg = email.mime.text.MIMEText("")
        newmsg['To'] = ", ".join(to)
        newmsg['Subject'] = subject
        return self.editMessage(newmsg)

    @showExceptions
    @needsConnection
    def do_reply(self, args):
        C = self.C
        M = C.connection
        if args:
            try:
                index = int(args)
            except:
                print("bad arguments")
                return
        else:
            index = C.currentMessage
        if index == 0 or index > self.C.lastMessage:
            print("No applicable messages")
            return
        # TODO: Should generate the body the same way we do for printing (walk
        # through multiparts), and should decode each part (in particular,
        # undo base64 or quoted printable)
        data = M.fetch(index, '(BODY.PEEK[HEADER] BODY.PEEK[TEXT])')
        parts = processAtoms(data[0][1], self.C.settings)
        headers = parts[0][1]
        body = parts[0][3]
        hdrs = processHeaders(headers)
        if 'to' in hdrs:
            # There can be multiple 'to' lines, theoretically. Lets merge them
            # and then split the components
            to = ",".join(hdrs['to']).split(',')
        else:
            to = ""
        if 'subject' in hdrs:
            # Take the first subject we find.
            subject = "Re: " + hdrs['subject'][0]
        else:
            subject = "Re:"
        if 'from' in hdrs:
            from_ = hdrs['from'][0]
            # Prepend the sender to the to list
            to[0:0] = [from_]
        else:
            from_ = "unkown"
        newmsg = email.mime.text.MIMEText("Quoth %s\r\n%s" % (from_, body))
        newmsg['To'] = ", ".join(to)
        newmsg['From'] = self.C.settings['from'].value
        newmsg['Subject'] = subject
        if 'cc' in hdrs:
            newmsg['Cc'] = ", ".join(",".join(hdrs['cc']).split(','))
        print("Message to %s, replying to %s, subject %s" % (", ".join(to), from_, subject))
        return self.editMessage(newmsg)


    def editMessage(self, message):
        while True:
            try:
                # TODO: allow tabs in the input
                line = self.singleprompt("")
                # TODO: Allow ctrl+c to abort the message, but not mailnex
                # (e.g. at this stage, two ctrl+c would be needed to exit
                # mailnex. The first to abort the message, the second to exit
                # mailnex)
            except EOFError:
                line = '.'
            if line.startswith("~~"):
                # User wants to start the line with a tidle
                message.set_payload(message.get_payload() + line[1:] + '\r\n')
            elif line.startswith("~h"):
                print("""  Help:
                    ~~ Text -> ~ Text   (enter a line starting with a single '~' into the message)
                    .          Send message
                    ~.         Send message
                    ~p         Print current message.
                    ~q         Quit composing. Don't send. Append message to ~/dead.letter if save is set, unless 'drafts' is set.
                    ~v         Edit message in external (visual) editor
                    ~x         Quit composing. Don't send. Discard current progress.
                    """)
                # ~!command    = execute shell command
                # ~.           = same as end-of-file indicator (according to mailx)
                #                I feel like it ought to be to insert a literal dot. I can't find a way
                #                to do that in mailx. Maybe a setting to switch between the two operations?
                # ~<file       = same as ~r
                # ~<!command   = run command in shell, insert output into message
                # ~@           = edit attachment list
                # ~@ filename  = add filename to attachment list. Space separated list (according to mailx)
                # ~A           = insert string of the Sign variable (like '~i Sign)
                # ~a           = insert string of the sign variable (like '~i sign)
                # ~bname       = add names to bcc list (space separated)
                # ~cname       = add names to cc list (space separated)
                # ~d           = read ~/dead.letter into message
                # ~e           = edit current message in editor (default is ed?)
                # ~fmessage    = read messages (message ids) into message (or current message if none given). use format of print, but only include first part
                # ~Fmessage    = like ~f, but include all headers and mime parts
                # ~h           = edit headers (to, cc, bcc, subject)
                # ~H           = edit headers (from, reply-to, sender, organization). Once this command is used, ignore associated user settings
                # ~ivar        = insert value of variable into message.
                # ~mmessages   = read message like ~f, but include indentation.
                # ~Mmessages   = like ~m, but include all headers and MIME parts
                # ~p           = print message collected so far, prefaced by headers and postfixed by the attachment list. May be piped to pager.
                # ~q           = abort message, write to dead.letter IF 'save' is set.
                # ~rfile       = read file into message
                # ~sstring     = set subject to string
                # ~tname       = add names to To list (space separated) (direct recipient list)
                # ~v           = invoke alternate editor (VISUAL)
                # ~wfile       = write message to named file, appending if file exists TODO: Have a setting which fails if file exists (mailx doesn't write headers regardless of editheaders setting)
                # ~x           = like ~q, but don't save no matter what.
                # ~|command    = pipe message through shell command as a filter. Retain original if no output.
                # ~:command    = run our command (mailnex)
                # ~_command    = same as ~:
                # ~~string     = insert string prefixed by one '~'
                #
                #
            elif line == "." or line.startswith("~."):
                # Send message
                break
            elif line.startswith("~q"):
                if 'drafts' in self.C.settings:
                    print("Sorry, drafts setting is TBD")
                if 'save' in self.C.settings:
                    # TODO: Handle errors here. We want to try hard to not lose
                    # the user's message if at all possible.
                    ofile = open("%s/dead.letter" % os.environ['HOME'], "a")
                    # This is probably not the right format for dead.letter
                    ofile.write("From user@localhost\r\n%s\r\n" % (message.as_string()))
                return
            elif line.startswith("~x"):
                print("Message abandoned")
                return
            elif line.startswith("~p"):
                print(message.as_string())
                #print("Message\nTo: %s\nSubject: %s\n\n%s" % (to, subject, messageText))
            elif line.startswith("~v"):
                f=tempfile.mkstemp()
                #TODO: If editHeaders is set, also save the headers
                os.write(f[0], message.get_payload())

                # Would normally do cli.run_in_terminal, but that tries to
                # obtain the cursor position when done by asking the terminal
                # for it, but doesn't read it back in; it expects that the cli
                # will start running again and it'll pick up the response in
                # the normal loop. Unfortunately, we aren't returning to the
                # cli's loop here, we're invoking a different temporary one.
                #
                # Instead, we'll do just part of what run_in_terminal does,
                # that is, set the terminal up for "normal" use while we
                # invoke our terminal-using function
                with self.cli.input.cooked_mode():
                    # For whatever reason, vim complains the input isn't from
                    # the terminal unless we redirect it ourselves. I'm
                    # guessing prompt_toolkit changed python's stdin somehow
                    res = os.system("vim %s </dev/tty" % f[1])
                if res != 0:
                    print("Edit aborted; message unchanged")
                else:
                    os.lseek(f[0], 0, os.SEEK_SET)
                    fil = os.fdopen(f[0])
                    message.set_payload(fil.read())
                    fil.close()
                    del fil
                    os.unlink(f[1])
                    #TODO: If editHeaders is set, retrieve those headers
            # TODO: The other ~* functions from mailx.
            # TODO: Extension commands. E.g. we might want "~save <path>" to
            # save a copy of the message to the given path, but keep editing.
            # We definitely want a way to edit an attachment (properties and
            # contents), and to add/edit arbitrary message parts. Should be
            # able to mark parts for signing, encryption, compression, etc.
            else:
                message.set_payload(message.get_payload() + line + '\r\n')

        message.set_payload(quopri.encodestring(message.get_payload()))
        message.set_charset("utf-8")
        del message['Content-transfer-encoding']
        message['Content-Transfer-Encoding'] = 'quoted-printable'
        # m is the outer message. message is the text part of the message.
        # Simple case, these are the same. Eventually, m is a
        # multipart/something that contains message somewhere within it. This is
        # the case for at least rich text, file attachments, and
        # signature/encryption messages. We'll start simple.
        m = message
        # Mandatory headers: From: and Date:
        # TODO: Allow this to be set by the user on a per-message basis
        if not 'From' in m:
            m['From'] = self.C.settings['from'].value
        if not 'Date' in m:
            m['Date'] = email.utils.formatdate(localtime=True) # Allow user to override local and possibly timezone?
        # Should headers: Message-Id
        if not 'Message-Id' in m:
            m['Message-Id'] = email.utils.make_msgid("mailnex")
        # Misc headers
        if not 'User-Agent' in m:
            # TODO: User-Agent isn't actually a mail header, it is a news
            # header. IANA doesn't currently recognize any header for email
            # MUA. mailx and Thunderbird us User-Agent. Eudora and Outlook use X-Mailer.
            m['User-Agent'] = 'mailnex 0.0' # TODO: Use global version string; allow user override
        # TODO: break out sending the message to a function. The function
        # should be invoked by the caller of this function instead of this
        # function. Rationale: perhaps we want to support editing a message
        # without sending it
        #
        # Broken out function should probably be replaceable or configurable.
        # For example, should support sending via sendmail or smtp.
        s = subprocess.Popen([
            # TODO: Allow the user to override this somehow
            "sendmail", # Use sendmail to, well, send the mail
            "-bm", # postfix says this is "read mail from stdin and arrange for delivery". Hopefully this is standard across implementations
            "-i", # Don't use '.' as end of input. Hopefully this means we don't have to do dot stuffing.
            # TODO: Support delivery status notification settings? "-N" "failure, delay, success, never"
            "-t", # Get recipients from message headers. TODO: We should specify the addresses on sendmail's commandline such that we can manage the Bcc list.
            ],
            stdin=subprocess.PIPE)
        s.communicate(m.as_string())


    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_mheader(self, msglist):
        C = self.C
        M = C.connection
        if msglist is None:
            index = C.currentMessage
            if index == 0 or index > self.C.lastMessage:
                print("No applicable messages")
                return
        elif len(msglist) == 0:
            print("No matches")
            return
        else:
            # For now, only support showing one set of headers. This is a
            # debugging command for now anyhow.
            index = msglist[0]
        data = M.fetch(args, '(BODY.PEEK[HEADER])')
        headers = processHeaders(processAtoms(data[0][1])[0][1], self.C.settings)
        if "subject" in headers:
            print("Subject:", headers["subject"][-1])
        if "date" in headers:
            print("Date:", headers["date"][-1])
        if "from" in headers:
            print("From:", headers['from'][-1])

        print()
        for key,val in headers.iteritems():
            for i in range(len(val)):
                print("%s[%i]=%s" % (key, i, repr(val)))

    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_structure(self, msglist):
        C = self.C
        M = C.connection
        if msglist is None:
            index = C.currentMessage
            if index == 0 or index > self.C.lastMessage:
                print("No applicable messages")
                return
        elif len(msglist) == 0:
            print("No matches")
            return
        else:
            # For now, only support showing one set of headers.
            index = msglist[0]
        data = M.fetch(index, '(BODYSTRUCTURE)')
        #print(data)
        for entry in data:
            #print(entry)
            try:
                # We should get a list of the form (ID, DATA)
                # where DATA is a list of the form ("BODYSTRUCTURE", struct)
                # and where struct is the actual structure
                d = processAtoms(entry[1], self.C.settings)
                val = str(entry[0])
                d = d[0]
            except Exception as ev:
                print(ev)
                return
            if d[0] != "BODYSTRUCTURE":
                print("fail?")
                print(d)
                return
            res = unpackStruct(d[1], self.C.settings, tag=val)
            if C.settings.debug.struct:
                print("---")
            def disp(struct):
                extra = ""
                if hasattr(struct, "disposition") and struct.disposition not in [None, "NIL"]:
                    extra += " (%s)" % struct.disposition[0]
                    # TODO: Add filename if present
                # TODO XXX: Preprocess control chars out of all strings before
                # display to terminal!
                print("%s   %s/%s%s" % (struct.tag, struct.type_, struct.subtype, extra))
                if isinstance(struct, structureMessage):
                    extra = ""
                    # Switch to the inner for further processing
                    struct = struct.subs[0]
                    if hasattr(struct, "disposition") and struct.disposition not in [None, "NIL"]:
                        extra += " (%s)" % struct.disposition[0]
                    print("%*s   `-> %s/%s%s" % (len(struct.tag), "", struct.type_, struct.subtype, extra))
                if hasattr(struct, "subs"):
                    for i in struct.subs:
                        disp(i)
            disp(res)

    @shortcut("h")
    @showExceptions
    @needsConnection
    @argsToMessageList
    def do_headers(self, msglist):
        """List headers around the current message. (h for short)"""
        # heirloom-mailx says that it gives 18-message groups, but actually
        # shows about how many will fit on the active terminal.
        # It also says that a '+' argument shows the next 18 message group and
        # '-' shows the previous group. In practice, I've only seen '-' work,
        # and then only if the first message in the group is the active one
        # (otherwise '-' re-lists with the first message selected). I suspect
        # '+' will show the next group *if* the last message in the group is
        # the active one, but I haven't tested.
        C = self.C
        M = C.connection
        if msglist is not None:
            if len(msglist) == 0:
                print("No matches")
                return
            C.currentMessage = msglist[0]
            C.lastList = msglist
        rows = 25 # TODO get from terminal
        start = (C.currentMessage - 1) // rows * rows
        # ^- alternatively, start = C.currentMessage - (C.currentMessage % rows)
        start += 1 # IMAP is 1's based
        last = start + rows - 1
        if msglist:
            # mailx has this behaviour where specifying a location causes the
            # current message to become the first message in the list of
            # headings that contains the requested message. It is a bit
            # confusing, but it is expected by long-time (and medium time)
            # users.
            C.currentMessage = start
        if self.C.virtfolder:
            lastMessage = len(self.C.virtfolder)
        else:
            lastMessage = C.lastMessage
        if last > lastMessage:
            last = lastMessage
        if last == 0:
            print("No applicable messages")
            return
        if self.C.settings.headerstats:
            print("Page {current} of {last}, {rows} per page".format(
                current = (start - 1) // rows,
                last = (lastMessage - 1) // rows,
                rows = rows,
                ))
        self.showHeaders("%i:%i" % (start, last))

    def showHeaders(self, messageList):
        if self.C.virtfolder:
            start,end = map(int,messageList.split(':'))
            messageList=','.join(map(str,[self.C.virtfolder[x-1] for x in range(start,end+1)]))
        msgset = "%s" % messageList
        args = "(ENVELOPE INTERNALDATE FLAGS)"
        if self.C.settings.debug.general:
            print("executing IMAP command FETCH {} {}".format(msgset, args))
        data = self.C.connection.fetch(msgset, args)
        #data = normalizeFetch(data)
        for d in data:
            try:
                d = (d[0], processAtoms(d[1], self.C.settings))
            except Exception as ev:
                print("  %s  (error parsing envelope!)" % d[0], ev)
                continue
            envelope = getResultPart("ENVELOPE", d[1][0])
            internaldate = getResultPart("INTERNALDATE", d[1][0])
            flags = getResultPart("FLAGS", d[1][0])
            envelope = Envelope(*envelope)

            # Handle attrs. First pass, only do collapsed form.
            # TODO for second pass, define a class that is initialized with
            # the flags (and possibly other data) with a __format__  method
            # that allows the user to specify groups of characters with
            # priorities. E.g. first char is the NURO set, second is flagged,
            # third is answered, 4+ is whatever is left.
            # TODO: The priorities for flags are guessed by me based on what
            # I'd want to see. I'm guessing there's a POSIX standard for this.
            # Or I could look at mailx source code, but so far I've done
            # neither.
            uflags = map(lambda x: x.upper(), flags)
            if '\FLAGGED' in uflags:
                attr = self.C.settings.attrlist.value[ATTR_FLAGGED]
            elif '\DRAFT' in uflags:
                attr = self.C.settings.attrlist.value[ATTR_DRAFT]
            elif '\ANSWERED' in uflags:
                attr = self.C.settings.attrlist.value[ATTR_ANSWERED]
            elif '\RECENT' in uflags:
                if '\SEEN' in uflags:
                    attr = self.C.settings.attrlist.value[ATTR_NEWREAD]
                else:
                    attr = self.C.settings.attrlist.value[ATTR_NEW]
            else:
                if '\SEEN' in uflags:
                    attr = self.C.settings.attrlist.value[ATTR_OLD]
                else:
                    attr = self.C.settings.attrlist.value[ATTR_UNREAD]

            try:
                gnum = int(d[0])
                if self.C.virtfolder:
                    num = self.C.virtfolder.index(int(d[0])) + 1
                else:
                    num = gnum
                datestr = envelope.date
                if datestr == 'NIL' or datestr == None:
                    datestr = internaldate
                if datestr == None or datestr == "NIL":
                    date = nodate()
                else:
                    try:
                        date = dateutil.parser.parse(datestr)
                    except ValueError:
                        print("Couldn't parse date string", datestr)
                        date = nodate()
                    if date.tzinfo is None:
                        date = date.replace(tzinfo = dateutil.tz.gettz(self.C.settings['defaultTZ'].value))
                    # TODO: Make setting for local or original timezone. Or
                    # perhaps better, make it part of the headline setting so if
                    # the user wants, they can see both.
                    date = date.astimezone(dateutil.tz.tzlocal())
                subject = envelope.subject
                this = True if (num == self.C.currentMessage) else False
                froms = [x[0] if not x[0] in [None, 'NIL'] else "%s@%s" % (x[2], x[3]) for x in envelope.from_]
                if self.C.virtfolder and len(self.C.settings.headlinevf.value):
                    headline = self.C.settings.headlinevf.value
                else:
                    headline = self.C.settings.headline.value
                print(headline.format(**{
                        'attr': attr,
                        'this': '>' if this else ' ',
                        'num': num,
                        'gnum': gnum,
                        'date': date.strftime("%04Y-%02m-%02d %02H:%02M:%02S"),
                        'subject': subject,
                        'flags': " ".join(flags),
                        'from': froms[0],
                        't': self.C.t,
                    }))
            except Exception as ev:
                print("  %s  (error displaying because %s '%s'. Data follows)" % (d[0], type(ev), ev), repr(d))

    @shortcut("f")
    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_from(self, msglist):
        """List messages (like headers command) for given message list only."""
        # I originally thought 'f' was short for 'find' or something like
        # that. As near as I can guess, earlier implementations of mailx
        # (mail?) took only the straight email address method of selecting
        # message list. Later others were added, but the name was fixed.
        C = self.C
        M = C.connection
        if msglist is None:
            msglist = [self.C.currentMessage]
        elif len(msglist) == 0:
            print("No matches")
            return

        self.showHeaders("%s" % ",".join(map(str,msglist)))
        C.nextMessage = C.currentMessage

    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_flag(self, msglist):
        """Flag messages.

        Marks messages as 'flagged'. Flagged messages show up with the ":f" message specifier.
        This is similar to marking a message as a favorite or "starring" or "pinning" in other systems.
        There is no special meaning to flagged messages; it is just a marking."""
        if msglist is None:
            msglist = [self.C.currentMessage]
        elif len(msglist) == 0:
                print("No matches")
                return
        if self.C.virtfolder:
            msglist = [self.C.virtfolder[x - 1] for x in msglist]
        try:
            self.C.connection.doSimpleCommand("STORE %s +FLAGS (\Flagged)" % ",".join(map(str,msglist)))
            # TODO: either run once per flag, or collect errors to show at
            # end.
        except Exception as ev:
            print("Failed to flag: %s" % ev)

    @showExceptions
    @needsConnection
    @argsToMessageList
    @updateMessageSelectionAtEnd
    def do_unflag(self, msglist):
        """Remove Flag from messages.

        see flag command for information. This command undoes that one.
        """
        if msglist is None:
            msglist = [self.C.currentMessage]
        elif len(msglist) == 0:
                print("No matches")
                return
        if self.C.virtfolder:
            msglist = [self.C.virtfolder[x - 1] for x in msglist]
        try:
            self.C.connection.doSimpleCommand("STORE %s -FLAGS (\Flagged)" % ",".join(map(str, msglist)))
            # TODO: either run once per flag, or collect errors to show at
            # end.
        except Exception as ev:
            print("Failed to unflag: %s" % ev)

    @showExceptions
    @needsConnection
    def do_namespace(self, args):
        C = self.C
        M = C.connection
        res,data = M.namespace()
        #print(res)
        try:
            data = processAtoms(data[0], self.C.settings)
        except Exception as ev:
            print(ev)
            return
        print("Personal namespaces:")
        for i in data[0]:
            print(i)
        print("Other user's namespaces:")
        for i in data[1]:
            print(i)
        print("Shared namespaces:")
        for i in data[2]:
            print(i)

    def search(self, terms, offset=0, pagesize=10):
        C = self.C
        dbpath = C.dbpath
        db = xapian.Database(dbpath)

        queryparser = xapian.QueryParser()
        queryparser.set_stemmer(xapian.Stem("en"))
        queryparser.set_stemming_strategy(queryparser.STEM_SOME)
        queryparser.add_prefix("subject", "S")
        queryparser.add_prefix("from", "F")
        queryparser.add_prefix("to", "T")
        queryparser.add_prefix("cc", "C")
        queryparser.add_prefix("thread", "I")
        queryparser.add_prefix("ref", "R")
        queryparser.add_prefix("prev", "P")
        queryparser.add_prefix("id", "M")
        queryparser.add_prefix("date", "D")
        queryparser.set_database(db)
        query = queryparser.parse_query(terms, queryparser.FLAG_BOOLEAN | queryparser.FLAG_WILDCARD)
        enquire = xapian.Enquire(db)
        enquire.set_query(query)
        matches = []
        data = []
        for match in enquire.get_mset(offset, pagesize):
            fname = match.document.get_data()
            data.append(fname)
            matches.append(match)

        #print(data[0])
        return data, matches

    @showExceptions
    def do_search(self, args, offset=0, pagesize=10):
        C = self.C
        C.lastsearch = args
        C.lastsearchpos = offset
        C.lastcommand="search"
        data, matches = self.search(args, offset, pagesize)
        for i in range(len(data)):
            fname = data[i]
            match = matches[i]
            fname = fname.split('\r\n')
            fname = filter(lambda x: x.lower().startswith("subject: "), fname)
            if len(fname) == 0:
                fname = "(no subject)"
            else:
                fname = fname[0]
            print(u"%(rank)i (%(perc)3s %(weight)s): #%(docid)3.3i %(title)s" % {
                    'rank': match.rank + 1,
                    'docid': match.docid,
                    'title': fname,
                    'perc': match.percent,
                    'weight': match.weight,
                    }
                    )

    @showExceptions
    def do_unset(self, args):
        """Unset an option.

        For program options, this restores the default value (same as 'set {option}&').
        For user options, removes the option from the system."""
        try:
            opt = self.C.settings[args]
            if isinstance(opt, settings.UserOption):
                self.C.settings.removeOption(args)
                # Remove user option
                pass
            else:
                # Restore default value
                opt.value = opt.default
        except KeyError:
            print("No setting named %s" % args)

    @showExceptions
    def do_set(self, args):
        """Set or get option values

        set                 show options that differ from their default value
        set all             show all options and their values
        set {option}?       show value of given option
        set {option}??      show default and current values of option with description
        set {option}&       reset option to default
        set {option}        assert a boolean option
        set no{option}      deassert a boolean option
        set inv{option}     toggle a boolean option
        set {option}!       equivalent to inv{option}
        set {option}={val}  set numeric, string, or flag list option to val.
                            Numbers are decimal, unles prefixed by 0x for hex
                            or 0 for octal.
        set {option}+={val} Append val to string or flag list. Increment
                            numeric option by val
        set {option}^={val} Prepend val to string or flag list. Multiply
                            numeric option by val
        set {option}-={val} Remove val from string or flag list. Subtract
                            numeric option by val"""
        if args == "":
            # TODO: order by type (e.g. booleans first)
            for opt in self.C.settings:
                if opt.value != opt.default:
                    print(opt)
        elif args == "all":
            # TODO: order by type (e.g. booleans first)
            for opt in self.C.settings:
                print(opt)
        else:
            sep = args.find('=')
            if sep == -1:
                # No equals, might be boolean or reset to default...
                if args[-2:] == '??':
                    # Print details
                    try:
                        opt = self.C.settings[args[:-2]]
                    except KeyError:
                        print("No setting named %s" % args[:-2])
                    print("Setting: %s" % args[:-2])
                    # TODO: Show type
                    print("Description:")
                    if not opt.doc:
                        print("  (none given)")
                    else:
                        for line in opt.doc.split("\n"):
                            print("   %s" % line)
                    oldval = opt.value
                    opt.value = opt.default
                    print("Default:", opt)
                    opt.value = oldval
                    print("current:", opt)
                elif args[-1] == '?':
                    # Print current value
                    try:
                        print(self.C.settings[args[:-1]])
                    except KeyError:
                        print("No setting named %s" % args[:-1])
                elif args[-1] == '&':
                    # Reset to default value
                    try:
                        opt = self.C.settings[args[:-1]]
                    except KeyError:
                        print("No setting named %s" % args[:-1])
                    opt.value = opt.default
                elif args[-1].isalpha():
                    # Must be a boolean
                    print("nye")
                else:
                    print("invalid suffix")
                return
            else:
                if sep == 0:
                    print("invalid")
                    return
                mod = args[sep - 1]
                if mod == '+':
                    # Add/append
                    print("nye")
                    return
                elif mod == '^':
                    # multiply/prepend
                    print("nye")
                    return
                elif mod == '-':
                    # subtract/remove
                    print("nye")
                    return
                elif not mod.isalpha:
                    # Weird, perhaps an operator we'll have in the future?
                    print("invalid operator")
                    return
                else:
                    # Straight assignment
                    key,value = map(lambda x: x.strip(), args.split('=', 1))
                    try:
                        try:
                            self.C.settings[key] = value
                        except KeyError:
                            self.C.settings.addOption(settings.UserOption(key, None))
                            self.C.settings[key] = value
                    except ValueError:
                        print("Invalid value for setting")

    @shortcut("vf")
    @showExceptions
    @needsConnection
    @argsToMessageList
    def do_virtfolder(self, args):
        if args is not None and len(args) == 0:
            print("No Matches")
            args = None
        if args is None:
            if self.C.virtfolder:
                # We were in virtfolder mode, so restore selection
                (self.C.currentMessage, self.C.nextMessage, self.C.prevMessage, self.C.lastList) = self.C.virtfolderSavedSelection
            self.C.virtfolder = None
            self.setPrompt("mailnex> ")
        else:
            self.C.virtfolder = args
            self.setPrompt("mailnex (vf-{})> ".format(len(args)))
            self.C.virtfolderSavedSelection = (self.C.currentMessage, self.C.nextMessage, self.C.prevMessage, self.C.lastList)
            self.C.currentMessage = 1
            self.C.nextMessage = 1
            self.C.prevMessage = None
            self.C.lastList = []

    @showExceptions
    @needsConnection
    def do_z(self, args):
        """Scroll pages of headers

        On its own, go to next page.
        Given a +/-, go to next/previous page.
        Given a number, go to that page number.
        Given +/- and a number, go that many pages forward/back.
        The first page is page 0
        The last page is $
        """
        # TODO: Allow pages to be 1's based indexing, most of the rest of this
        # program is 1's based (the first message is message 1, not 0). Should
        # be an option.

        # First, find out where we are
        rows = 25
        if self.C.virtfolder:
            lastMessage = len(self.C.virtfolder)
        else:
            lastMessage = self.C.lastMessage
        start = (self.C.currentMessage - 1) // rows * rows
        # ^- alternatively, start = self.C.currentMessage - (self.C.currentMessage % rows)
        # Next, figure out where we are going
        if not args:
            args = '+1'
        elif args == '+':
            args = '+1'
        elif args == '-':
            args = '-1'
        if args[0] not in ['+', '-']:
            # Absolute page
            if args == '$':
                start = (lastMessage - 1) // rows * rows
            elif not args.isdigit():
                print("unrecognized scrolling command \"%s\"" % args)
                return
            else:
                start = int(args) * rows
        else:
            # Relative page
            if not args[1:].isdigit():
                print("unrecognized scrolling command \"%s\"" % args)
                return
            if args[0] == '+':
                start += int(args[1:]) * rows
            else:
                start -= int(args[1:]) * rows
        if start < 0:
            print("On first page of message")
            start = 0
        if start > lastMessage - 1:
            print("On last page of messages")
            start = (lastMessage - 1) // rows * rows
        start += 1 # IMAP is 1's based
        last = start + rows - 1
        if last > lastMessage:
            last = lastMessage
        self.C.prevMessage = self.C.currentMessage
        self.C.currentMessage = start
        self.C.nextMessage = start
        # NOTE: in mailx, this command does not 'mark any messages', which is
        # to say, doesn't update the lastList (whereas 'headers' with an
        # argument does)
        if self.C.settings.headerstats:
            print("Page {current} of {last}, {rows} per page".format(
                current = (start - 1) // rows,
                last = (lastMessage - 1) // rows,
                rows = rows,
                ))
        self.showHeaders("%i:%i" % (start, last))

    @showExceptions
    @needsConnection
    def do_Z(self, args):
        """Like z, but for interesting messages.

        Goes to page with flagged or new (not just unread) messages.

        Unlike z, doesn't take numbers, only nothing, +, or -
        """
        # TODO: Allow it to take numbers? Presumably, this would select the
        # page among the interesting pages, so the first thing to do is get a
        # list of interesting pages, then figure out where we are, then move
        # through the list. We have to do most of that anyway, so I don't know
        # why mailx doesn't do this. Maybe they do a linear search?
        rows = 25
        if self.C.virtfolder:
            lastMessage = len(self.C.virtfolder)
        else:
            lastMessage = self.C.lastMessage
        #TODO: Make 'interesting' criteria a user setting
        msgs = map(int,self.C.connection.search('utf-8', '(or FLAGGED NEW)'))
        if self.C.virtfolder:
            msgs = [self.C.virtfolder.index(x) for x in msgs if x in self.C.virtfolder]
        if self.C.settings.debug.general:
            print("{} msgs {}".format(len(msgs), msgs))
        # Observing mailx behavior, if there isn't anything interesting, go to
        # the last page. If we were on the last page, and '-' isn't specified
        # in args, display also the "On last page or messages" message.
        # Likewise, if the current page is after the last interesting page,
        # display the message and go to the last interesting page.
        # This should be able to be generalized by selecting the last message
        # for the target page and performing the normal actions.
        if len(msgs) == 0:
            msgs = [lastMessage]
        # These ignores feel dirty
        ignoreFirstPage = False
        ignoreLastPage = False
        # Current information.
        currentPage = (self.C.currentMessage - 1) // rows
        lastPage = (lastMessage - 1) // rows
        interestingPages = sorted(list(set((x - 1) // rows for x in msgs)))
        if self.C.settings.debug.general:
            print("Current {}\nLast {}\n{} Interesting {}\n".format(currentPage, lastPage, len(interestingPages), tuple((x, x * rows) for x in interestingPages)))
        if currentPage in interestingPages:
            i = interestingPages.index(currentPage)
            addedPage = False
            incDrop = False
        else:
            # insert current page into list so that we can get a list index
            # for it. There is surely a more effecient way to do this, but I'm
            # hoping no one has a huge list of interesting messages anyway.
            for i in range(len(interestingPages)):
                if interestingPages[i] > currentPage:
                    interestingPages.insert(i, currentPage)
                    if (i == 0):
                        ignoreFirstPage = True
                    break
            else:
                # Didn't find it yet, so we must be biggest, append to list
                interestingPages.append(currentPage)
                i += 1
                ignoreLastPage = True
            addedPage = True
            incDrop = True
        if self.C.settings.debug.general:
            print("page index {} of {}".format(i, interestingPages))
        # Now proceed like 'z', but on our list. Also, don't accept anything
        # other than '+' and '-' (for whatever reason). TODO: Allow it via an
        # option? Just allow it anyhow?
        if not args:
            args = "+"
        if args == "+":
            i += 1
            if i >= len(interestingPages) - int(ignoreLastPage):
                print("On last page of messages")
                i = len(interestingPages) - 1 - int(ignoreLastPage)
                incDrop = False
        elif args == "-":
            incDrop = False # don't drop the index for negative going movement
            i -= 1
            if i < 0 + int(ignoreFirstPage):
                print("On first page of messages")
                i = 0 + int(ignoreFirstPage)
                incDrop = addedPage
        else:
            print("Bad argument to Z")
            return
        page = interestingPages[i]
        start = page * rows + 1
        end = (page + 1) * rows
        if end > lastMessage:
            end = lastMessage
        self.C.prevMessage = self.C.currentMessage
        self.C.currentMessage = start
        self.C.nextMessage = start
        if self.C.settings.headerstats:
            print("Page {current} of {last}, Interesting Page {icurrent} of {ilast}, {rows} per page".format(
                current = (start - 1) // rows,
                last = (lastMessage - 1) // rows,
                icurrent = i - int(incDrop),
                ilast = len(interestingPages) - 1 - int(addedPage),
                rows = rows,
                ))
        self.showHeaders("{}:{}".format(start, end))

    @showExceptions
    def do_quit(self, args):
        # TODO: Support synchronizing if user setting asks for it. Something like:
        #print("Synchronizing events")
        #for i in self.C.pending:
            #print(" ",i)
            #self.commitaction(i)
        # TODO: Synchronize and quit
        return True

    @showExceptions
    def do_exit(self, args):
        # TODO: Disconnect but not synchronize and quit
        return True

    @showExceptions
    def do_python(self, args):
        if self.C.settings.debug.python:
            res = eval(args)
            if res is not None:
                print(repr(res))

def interact():
    cmd = Cmd(prompt="mailnex> ", histfile="mailnex_history")
    C = Context()
    C.dbpath = "./maildb1/" # TODO: get from config file or default to XDG data directory
    C.lastcommand=""
    cmd.C = C
    options = settings.Options()
    options.addOption(settings.StringOption("attrlist", "NUROSPMFATK+-J", doc=
        """Character mapping for attribute in headline.

        Characters represent: new, unread but old, new but read, read and old,
        saved, preserved, mboxed, flagged, answered, draft, killed, thread
        start, thread, and junk.

        Currently, we don't support saved, preserved, mboxed, killed, threads,
        or junk.

        Default mailx (presumably POSIX) is "NUROSPMFATK+-J".
        BSD style uses "NU  *HMFATK+-J.", which is read messages aren't
        marked, and saved/preserved get different letters (presumably 'Held'
        instead of 'Preserved')
        """
        ))
    # Debug options:
    #   exception - show detailed exceptions instead of short messages
    #   general - show general tidbits during runtime
    #   imap - debug output from imap handler
    #   parse - debug output from parsers (e.g. atoms and such)
    #   struct - debug output from structure heirarchy parser
    options.addOption(settings.FlagsOption("debug", []))
    # Use the username and hostname of this machine as a (hopefully reasonable)
    # guess for the from line.
    options.addOption(settings.StringOption("from", "%s@%s" % (getpass.getuser(), os.uname()[1]), doc="Value to use for From field of composed email messages"))
    options.addOption(settings.BoolOption("headerstats", 0, doc="Show information about the page of message headers displayed in headers and z/Z commands"))
    options.addOption(settings.StringOption("PAGER", "internal"))
    options.addOption(settings.StringOption("defaultTZ", "UTC"))
    options.addOption(settings.BoolOption("allpartlabels", 0, doc="Show all part separation labels when displaying multi-part messages in print.\nWhen unset, only show separators for sub-messages."))
    options.addOption(settings.BoolOption("receiptheaders", 0, doc="Show headers for messages as they arrive"))
    options.addOption(settings.StringOption("headline", "{this}{attr}{num:4} {date:19} {from:<15.15} {t.italic_blue}{subject:<30.30}{t.normal} |{flags}",
        doc="""Format string for headers lines (e.g. in headers and from commands)

        The format string follows the python format specification.
        Field replacement is done between braces.
        Literal braces must be doubled.

        For example: "this {{is}} the {subject}" where subject is
        "red ball" results in "this {is} the red ball"

        Field width and precision can be used to make the output columnar.
        E.g. {subject:<30.30} pads or truncates the subject to exactly 30
        characters. Instead of '<' you can use '>' to right align or '^' to
        center the subject.

        The following are currently supported fields (subject to change):

            this        - a '>' if the message is the current message, a
                          space otherwise (%> from mailx)
            attr        - Collapsed attribute from attrlist setting ('%a'
                          from mailx) when plain. Use format for more control.
            num         - the message number (%m from mailx)
            date        - the message date - TODO: custom date formatting
                          (roughly %d)
            subject     - the subject of the message (%s)
            flags       - space saparated list of imap flags
            from        - first from entry as name or address (TODO: setting to control that)
                          (%f from mailx)
            t           - terminal attributes. Use as 't.red' to make following
                          text red, or 't.bold' for bold. 't.normal' returns to
                          normal text. Attributes can be combined:
                          't.italic_blue_on_red' makes italic blue text on red
                          background.
        """))
    options.addOption(settings.StringOption("headlinevf", "{this}{attr}{num:2}(g{gnum:4}) {date:19} {from:<15.15} {t.italic_blue}{subject:<30.30}{t.normal} |{flags}", doc="Headline in virtual folder mode. If blank, use normal headline."))
    options.addOption(settings.StringOption("folder", "", doc="Replacement text for folder related commands that start with '+'"))
    options.addOption(settings.StringOption("cacertsfile", "/etc/ssl/certs/ca-certificates.crt", doc="""File containing trusted certificate authorities for validating SSL/TLS connections.

    For local imap servers, you can set this to the public cert file of the
    server, for example '/etc/dovecot/dovecot.pem'"""))
    C.settings = options
    postConfFolder = None
    if confFile:
        # Walk through the config file
        with open(confFile) as conf:
            print("reading conf from", confFile)
            for lineno, line in enumerate(conf, 1):
                if line.strip() == "":
                    # Blank line
                    continue
                elif line.strip().startswith('#'):
                    #print("comment")
                    continue
                elif line.strip().startswith("set "):
                    #print("setting", line.strip()[4:])
                    m = re.match(r' *([^ =]+) *= *(.+)', line[4:])
                    if not m:
                        print("Failed to parse set command in line %i" % lineno)
                        continue
                    key, value = m.groups()
                    try:
                        C.settings[key] = value
                    except KeyError:
                        C.settings.addOption(settings.UserOption(key, None))
                        C.settings[key] = value

                elif line.strip().startswith("folder "):
                    postConfFolder = line.strip()[7:]
                else:
                    print("unknown command in line %i" % lineno)
    if postConfFolder:
        cmd.do_folder(postConfFolder)
    C.t = blessings.Terminal()
    t = pyuv.Timer(cmd.ptkevloop.realloop)
    t.start(cmd.bgcheck, 1, 5)
    try:
        cmd.cmdloop()
    except KeyboardInterrupt:
        cmd.do_exit("")
    except Exception as ev:
        if options.debug.exception:
            raise
        else:
            print("Bailing on exception",ev)

if __name__ == "__main__":
    import sys
    interact()
